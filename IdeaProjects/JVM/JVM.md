# 《内存与垃圾回收》

## 一.内存结构概述

![image-20220210125830585](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220210125830585.png)

---



![image-20220210130117783](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220210130117783.png)

---

## 二.类加载器

![image-20220210130538368](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220210130538368.png)

- 类加载器子系统负责从文件系统或者网络中加载c1ass文件,c1ass文件在文件开头有特定的文件标识。
- Classloader只负责c1ass文件的加载,至于它是否可以运行,则由 Execution Engine决定。
- 加载的类信息存放于一块称为方法区的内存空间。除了类的信息外,方法区中还会存放运行时常量池信息,可能还包括字符串字面量和数字常量(这部分常量信息是C1ass文件中常量池部分的内存映射)

![image-20220210130734134](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220210130734134.png)

1. class file存在于本地硬盘上,可以理解为设计师画在纸上的模板,而最终这个模板在执行的时候是要加载到JVM当中来
   根据这个文件实例化出n个一模一样的实例。
2. class file加载到JVM中,被称为DNA元数据模板,放在方法区。
3. 在.class文件->JVM->最终成为元数据模板,此过程就要一个运输工具(类装载器 Class loader),扮演一个快递员的角色

---

### 类的加载过程

![image-20220210131115187](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220210131115187.png)

---



![image-20220210131212407](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220210131212407.png)

#### 加载:

1. 通过一个类的全限定名获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的java.lang.Class对象,作为方去区这个类的各种数据的访问入口

补充:加载.class文件的方式

- 从本地系统中直接加载
- 通过网络获取,典型场景: Web Applet
- 从zip压缩包中读取,成为日后jar、war格式的基础
- 运行时计算生成,使用最多的是:动态代理技术
- 由其他文件生成,典型场景:JSP应用
- 从专有数据库中提取.class文件,比较少见
- 从加密文件中获取,典型的防lass文件被反编译的保护措施

#### 链接:(link)

##### 验证( Verify):

* 目的在亍确保Class文件的字节流中包含信息符合当前虚拟机要求,保证被加载类的正确性,不会危害虚拟机自身安全
* 主要包括四种验证,文件格式验证,元数据验证,字节码验证,符号引用验证。

##### 推备( Prepare):

- 为类变量分配内存并且设置该类变量的默认初始值,即零值。
- 这里不包含用final修饰的 static,因为final在编译的时候就会分配了,准备阶段会显式初始化;
- 这里不会为实例变量分配初始化,类变量会分配在方法区中,而实例变量是会随着对象一起分配到Java堆中。

##### 解析( Resolve):

- 将常量池内的符号引用转换为直接引用的过程。
- 事实上,解析操作往往会伴随着JVM在执行完初始化之后再执行。
- 符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的Class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位
  到目标的句柄。
- 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info, CONSTANT_Fieldref_info, CONSTANT_Methodref_info等

#### 初始化:

- 初始化阶段就是执行类构造器方法<clinit>()的过程。
- 此方法不需定义,是 javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。
- 构造器方法中指令按语句在源文件中出现的顺序执行。
- <clinit>()不同于类的构造器。(关联:构造器是虚拟机视角下的<init>()
- 若该类具有父类,JVM会保证子类的<c1init>()执行前,父类的<c1init>()已经执行完毕。
- 虚拟机必须保证一个类的<clinit>()方法在多线程下被同步加锁。

### 类加载器分类

- JVM支持两种类型的类加载器,分别为引导类加载器( Bootstrap
  Classloader)和自定义类加载器(User- Defined Classloader)。
- 从概念上来讲,自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器,但是Java虚拟肌规范却没有这么定义,而是将所有派生于抽象类Classloader的类加载器都划分为自定义类加载器。
- 无论类加载器的类型如何划分,在程序中我们最常见的类加载器始终只有3种

![image-20220210135118002](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220210135118002.png)

#### 虚拟机自带的加载器

- 启动类加载器(引导类加载器, Bootstrap classloader)这个类加载使用C/C++语言实现的,嵌套在JVM内部。
- 它用来加载Java的核心库( JAVA HOME/jre/1ib/rt,jar、resources,jar或sun.boot.class.path路径下的内容),用于提供JVM自身需要的类
- 并不继承自java.1ang.Classloader,没有父加载器
- 加载扩展类和应用程序类加载器,并指定为他们的父类加载器。
  出于安全考虑, Bootstrap启动类加载器只加载包名为java.Javax、sun等开头的类

---

- 扩展类加载器( Extension Classloader)
- Java语言编写,由sun.misc.Launcher$ExtClassloader实现
  派生于Classloader类
- 父类加载器为启动类加载器
  从java.ext,dirs系统属性所指定的目录中加载类库,或从JDK的安
  装目录的jre/lib/ext子目录(扩展目录)下加载类库。如果用户创
  建的JAR放在此目录下,也会自动由扩展类加载器加载。

---

- 应用程序类加载器(系统类加载器, AppClassLoader)
- java语言编写,由sun.misc.Launcher$AppClassloader实现
- 派生于Classloader类
- 父类加载器内扩展类加载器
- 它负责加载环境变量 classpath或系统属性java, class.path指
  定路径下的类库
- 该类加载是程序中默认的类加载器,一般来说,Java应用的类都是由它来完成加载
- 通过Classloader# getSystemClassLoader()方法可以获取到该
  类加载器

#### 用户自定义类加载器

在Java的日常应用程序开发中,类的加载几乎是由上述3种类加载器相互配合执行的,在必要时,我们还可以自定义类加载器,来定制类的加载方式

##### 为什么要自定义类加载器?

- 隔离加载类
- 修改类加载的方式
- 扩展加载源
- 防止源码泄漏

##### 用户自定义类加载器实现步骤:

1. 开发人员可以通过继承抽象类java.lang.Classloader类的方式,实现自己的类加载器,以满足一些特殊的需求
2. 在JDK1.2之前,在自定义类加载器时,总会去继承Classloader类并重写loadclass()方法,从而实现自定义的类加载类,但是在JDK1.2之后已不再建议用户去覆盖1oadclass()方法,而是建议把自定义的类加载逻辑写在 findclass()方法中
3. 在编写自定义类加载器时,如果没有太过于复杂的需求,可以直接继承URLClassloader类,这样就可以避免自己去编写 findc1ass()方法及其获取字节码流的方式,使自定义类加载器编写更加简洁。

#### 关于ClassLoader

C] assloader类,它是一个抽象类,其后所有的类加载器都继承自
Classloader(不包括启动类加载器)

![image-20220211123422950](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220211123422950.png)

##### 继承关系

![image-20220211123537628](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220211123537628.png)

##### 获取类加载器的方法

![image-20220211123558174](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220211123558174.png)

### 双亲委派模式

Java虚拟机对class文件采用的是按需加载的方式,也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时,Java虚拟机采用的是**双亲委派模式**,即把请求交由父类处理它是一种**任务委派模式**。

#### 工作原理

1. 如果一个类加载器收到了类加载请求,它并不会自己先去加载,而是把这个请求委托给父类的加载器去执行
2. 如果父类加载器还存在其父类加载器,则进一步向上委托,依次递归请求最终将到达顶层的启动类加载器
3. 如果父类加载器可以完成类加载任务,就成功返回,倘若父类加载器无法完成此加载任务,子加载器才会尝试自己去加载,这就是双亲委派模式

![image-20220211124149488](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220211124149488.png)

---



![image-20220211124557573](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220211124557573.png)

##### 优势

- 避免类的重复加载
- 保护程序安全,防止核心API被随意篡改
  √自定义类:java.lang. string
  √自定义类:java.lang. Shkstart

#### 沙箱安全机制

自定义String类,但是在加载自定义 String类的时候会率先使用引导类加载器加载,而引导类加载害在加载的过程中会先加载jdk自带的文件(rt.jar包中java\lang\ string.class),报错信息说没有main方法就是因为加载的是rt.ar包中的 string类。这样可以保证对java核心源代码的保护,这就是**沙箱安全机制**。

### 其它

在JVM中表示两个class对象是否为同一个类存在两个必要条件:

1. 类的完整类名必须一致,包括包名
2. 加载这个类的classloader(指Classloader实例对象)必须相同。
   换句话说,在JVM中,即使这两个类对象(class对象)来源同一个Class文件,被同一个虚拟机所加载,但只要加载它们Classloader实例对象不同,那么这两个类对象也是不相等的。

JVM必须知道一个类型是由启动加载器加载的还是由用户类加载
器加载的。如果一个类型是由用户类加载器加载的,那么JVM会将这
个**类加载器的一个引用作为类型信息的一部分保存在方法区中**。当解析一个类型到另一个类型的引用的时候,JVM需要保证这两个类型的类加载器是相同的。



## 三.运行时数据区概述及线程

内存是非常重要的系统资源,是硬盘和CPU的中间仓库及桥梁,承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略,保证了JⅥ的高效稳定运行。不同的JVM对于内存的划分方式和管理机制存在着部分差异。结合JVM
虚拟机规范,来探讨一下经典的JM内存布局。

![image-20220211130204538](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220211130204538.png)

Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区,其中有一些会随着虚拟机启动而创建,随着虚拟机退出而销毁。另外一些则是与线程一一对应的,这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。

- 灰色的为单独线程私有的,红色的为多个线程共享的。即:
  每个线程:独立包括程序计数器、栈、本地栈。
- 线程间共享:堆、堆外内存(永久代或元空间、代码缓存)

![image-20220211130324673](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220211130324673.png)

### 线程

- 线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行。
- 在 Hotspot JVM里,每个线程都与操作系统的本地线程直接映射。
  - 当一个Java线程准备好执行以后,此时一个操作系统的本地线程也同时创建。Java线程执行终止后,本地线程也会回收。
- 操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功,它就会调用Java线程中的run()方法。

如果你使用 jconsle或者是任何一个调试工具,都能看到在后台有许多线程在运行。这些后台线程不包括调用 public static void main( string[] args)的main线程以及所有这个main线程自己创建的线程。
这些主要的后台系统线程在 Hotspot JVM里主要是以下几个:

- 虚拟机线程:这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点,这样堆才不会变化。这种线程的执行类型包括〃stop-the- world〃的垃圾收集,线程栈收集,线程挂起以及偏向锁撤销。
- 周期任务线程:这种线程是时间周期事件的体现(比如中断),他们一般用于周期性操作的调度执行。
- Gc线程:这种线程对在JVM里不同种类的垃圾收集行为提供了支持。
- 编译线程:这种线程在运行时会将字节码编译成到本地代码。信号调度线程:这种线程接收信号并发送给JVM,在它内部通过调用适当的方法进行处理

### pc寄存器

- JVM中的程序计数寄存器( Program Counter Register)中, Register的命名源于CPU的寄存器,寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。
- 这里,并非是广义上所指的物理寄存器,或许将其翻译为PC计数器(或指令计数器)会更加贴切(也称为程序钩子),并且也不容易引起一些不必要的误会。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟

#### 作用:

PC寄存器用来存储指向下一条指令的地址,也即将要执行的指令代码。由执行引擎读取下一条指令。

![image-20220211131417023](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220211131417023.png)

- 它是一块很小的内存空间,几乎可以忽略不记。也是运行速度最快的存储区域。
- 在JVM规范中,每个线程都有它自己的程序计数器,是线程私有的,生命周期与线程的生命周期保持一致。
- 任何时间一个线程都只有一个方法在执行,也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址;或者如果是在执行 native方法,则是未指定值( undefined)。
- 它是程序控制流的指示器,分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成
- 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令
- 它是唯一一个在Java虚拟机规范中没有规定任何 OutOfMemoryError情况的区域。

![image-20220211132401015](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220211132401015.png)

![image-20220211132659592](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220211132659592.png)

#### 两个常见问题

##### 使用PC寄存器存储字节码指令地址有什么用呢?

##### 为什么使用PC寄存记录当前线程的执行地址呢?

- 因为CPU需要不停的切换各个线程,这时候切换回来以后,就得知道接着从哪开始继续执行。
- JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。

##### PC寄存器为什么会被设定为线程私有?

- 我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法,CPU会不停地做任务切换,这样必然导致经常中断或恢复,如何保证分毫无差呢?为了能够准确地记录各个线程正在执行的当前字节码指令地址,最好的办法自然是为每一个线程都分配一个PC寄存器,这样一来各个线程之间便可以进行独立计算,从而不会出现相互干扰的情况。
- 由于CPU时间片轮限制,众多线程在并发执行过程中,任何一个确定的时刻,一个处理器或者多核处理器中的一个内核,只会执行某个线程中的一条指令。
- 这样必然导致经常中断或恢复,如何保证分毫无差呢?每个线程在创建后,都会产生自己的程序计数器和栈帧,程序计数器在各个线程之间互不影响。

---

### 虚拟机栈

- 由于跨平台性的设计,Java的指令都是根据栈来设计的。不同平台CPU架构不同,所以不能设计为基于寄存器的。
- 优点是跨平台,指令集小,编译器容易实现,缺点是性能下隆I实现同样的功能需要更多的指令。

**栈是运行时的单位,而堆是存储的单位**
即:栈解决程序的运行问题,即程序如何执行,或者说如何处理数据。

堆解决的是数据存储的问题,即数据怎么放、放在哪儿。

#### Java虚拟机栈是什么?

Java虚拟机栈( Java Virtual Machine Stack),早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈,其内部保存一个个的栈帧( Stack frame)l对应着一次次的Java方法调用。**是线程私有的**

1. 生命周期
   生命周期和线程一致。
2. 作用
   主管Java程序的运行,它保存方法的局部变量、部分结果,并参与方法的调用和返回。

##### 栈中可能出现的异常

Java虚拟机规范允许Java栈的大小是动态的或者是固定不变的。

- 如果采用固定大小的Java虚拟机栈,那每一个线程的Java虚拟机栈容量
- 可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量,Java虚拟机将会抛出一个
  Stack over flow Error异常
- 如果Java虚拟机栈可以动态扩展,并且在尝试扩展的时候无法申请到足够的内存,或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈那Java虚拟机将会抛出-个 Out of Memory Error异常。

##### 栈中存储什么?

- 每个线程都有自己的栈,栈中的数据都是以栈帧( Stack Frame)的格式存在。
- 在这个线程上正在执行的每个方法都各自对应一个栈帧( Stack frame)
- 栈帧是一个内存区块,是一个数据集,维系着方法执行过程中的各种数据信息。

JVM直接对Java栈的操作只有两个,就是对栈帧的压栈和岀栈,遵循“先进后出”/“后进先出”原则。

- 在一条活动线程中,一个时间点上,只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧(栈顶栈帧)是有效的,这个栈帧被称为当前栈帧( Current frame),与当前栈帧相对应的方法就是当前方法( Current Method),定义这个方法的类就是当前类( Current class)。
- 执行引擎运行的所有字节码指令只针对当前栈帧进行操作。如果在该方法中调用了其他方法,对应的新的栈帧会被创建出来,放在栈的顶端,成为新的当前帧。

- 不同线程中所包含的栈帧是不允许存在相互引用的,即不可能在一个栈帧之中引用另外一个线程的栈帧。如果当前方法调用了其他方法,方法返回之际,当前栈帧会传回此方法的执行结果给前一个栈帧,接着,虚拟机会丢弃当前栈帧,使得前一个栈帧重新成为当前栈帧。
- Java方法有两种返回函数的方式,一种是正常的函数返回,使用return指令;另外一种是抛出异常。不管使用哪种方式,都会导致栈帧被弹出。

##### 栈帧的内部结构

每个栈帧中存储着:

- **局部变量表(Local variables)**
- **操作数栈( Operand stack)(或表达式栈)**
- 动态链接( Dynamic Linking)(或指运行时常量池的方法引用)
- 方法返回地址( Return Address)(或方法正常退出或者异常退出的定义)
- 一些附加信息

![image-20220211141241504](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220211141241504.png)



![image-20220211141537559](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220211141537559.png)

---

#### 局部变量表

- 局部变量表也被称之为局部变量数组或本地变量表
- 定义为一个数字数组,主要用于存储方法参数和定义在方法体内的局部变量这些数据类型包括各类基本数据类型、对象引用(reference),以及return Address类型。
- 由于局部变量表是建立在线程的栈上,是线程的私有数据,因此不存在数据安全问题
- 局部变量表所需的容量大小是在编译期确定下来的,并保存在方法的Code属性的 maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。
- 方法嵌套调用的次数由栈的大小决定。一般来说,栈越大,方法嵌套调用次数越多。对一个函数而言,它的参数和局部变量越多,使得局部变量表膨胀,它的栈帧就越大,以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间,导致其嵌套调用次数就会减少。
- 局部变量表中的变量只在当前方法调用中有效。在方法执行时,虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后随着方法栈帧的销毁,局部变量表也会随之销毁。

##### 关于Slot的理解

- 参数值的存放总是在局部变量数组的 index 0开始,到数组长度-1的索引结束
- 局部变量表,最基本的存储单元是slot(变量槽)
- 局部变量表中存放编译期可知的各种基本数据类型(8种),引用类型( reference), return address类型的变量。
- 在局部变量表里,32位以内的类型只占用一个slot(包括
  return Address类型),64位的类型(long和double)占用两个slot。byte、 short、char在存储前被转换为int, boolean也被转
  换为int,0表示false,非0表示true。long和 double则占据两个slot。
- JVM会为局部变量表中的每一个slot都分配一个访问索引,通过这个素引即可成功访问到局部变量表中指定的局部变量值
- 当一个实例方法被调用的时候,它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个slot上
- 如果需要访问局部变量表中一个64bit的局部变量值时,只需要使用前一个索引即可。(比如:访问long或 double类型变量)
- 如果当前帧是由构造方法或者实例方法创建的,那么该对象引用this将会存放在 index为0的slot处,其余的参数按照参数表顺序继续排
- 栈帧中的局部变量表中的槽位是可以重用的,如果一个局部变量过了其作用域,那么在其作用域之后申眀的新的局部变量就很有可能会复用过期局部变量的槽位,从而达到节省资源的目的

##### 举例:静态变量与局部变量的对比

- 参数表分配完毕之后,再根据方法体内定义的变量的顺序和作用域分配。
- 我们知道类变量表有两次初始化的机会,第一次是在“准备阶段”,执行系统初始化,对类变量设置零值,另一次则是在“初始化”阶段,赋予程序员在代码中定义的初始值。
- 和类变量初始化不同的是,局部变量表不存在系统初始化的过程,这意味着一旦定义了局部变量则必须人为的初始化,否则无法使用。

```java
public void test(){
    int i;
    System.out.println(i)//报错,没有赋值
}
```

##### 补充说明

- 在栈帧中,与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时,虚拟机使用局部变量表完成方法的传递。
- 局部变量表中的变量也是重要的垃圾回收根节点,只要被局部变量表中直接或间接引用的对象都不会被回收。

---

#### 操作数栈

- 每一个独立的栈帧中除了包含局部变量表以外,还包含一个后进先出(Last-In- First-Out)的操作数栈,也可以称之为表达式栈(Expression Stack)
- 操作数栈,在方法执行过程中,根据字节码指令,往栈中写入数据或提取数据,即入栈(push)/出栈(pop)。
  - 某些字节码指令将值压入操作数栈,其佘的字节码指令将操作数取出栈。使用它们后再把结果压入栈。
  - 比如:执行复制、交换、求和等操作
- 操作数栈,主要用于保存计算过程的中间结果,同时作为计算过程中变量临时的存储空间。
- 操作数栈就是JVM执行引擎的一个工作区,当一个方渗刚开始执行的时候,一个新的栈帧也会随之被创建出来,这个方法的**操作数栈是空的。**
- 每一个操作数栈都会拥有一个明确的栈深度用于存储数值,其所需的最大深度在编译期就定义好了,保存在方法的Code属性中,为 max stack的值
- 栈中的任何一个元素都是可以任意的Java数据类型。
  - 32bi的类型占用一个栈单位深度
  - 64bit的类型占用两个栈单位深度
- 操作数栈并**非采用访问索引的方式来进行数据访问的**,而是只能通过标准的入栈(push)和出栈(pop)操作来完成一次数据访问

- 如果被调用的方法带有返回值的话,其返回值将会被压入当前栈帧的操作数栈中,并更新PC寄存器中下一条需要执行的字节码指令。
- 操作数栈中元素的数据类型必须与字节码指令的序列严格匹配,这由编译器在编译器期间进行验证,同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。
- 另外,我们说Java虚拟机的解释引擎是基于栈的执行引擎,其中的栈指的就是操作数栈。

##### 栈顶缓存

前面提过,基于栈式架构的虚拟机所使用的零地址指令更加紧凑,但完
成一项操作的时候必然需要使用更多的入栈和出栈指令,这同时也就意味着将需要更多的指令分派( instruction dispatch)次数和内存读/写次数。

由于操作数是存储在内存中的,因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题, HotSpot JVM的设计者们提出了栈顶缓存(TOS,Top-of- Stack Cashing)技术,将栈顶元素全部缓存在物理CPU的寄存器中,以此降低对内存的读/写次数,提升执行引擎的
执行效率。

#### 动态链接(或指向运行时常量池的方法引用)

- 每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接(Dynamic Linking)。比如: invoked Dynamic指令
- 在Java源文件被编译到字节码文件中时,所有的变量和方法引用都作为符号引用( Symbolic Reference)保存在class文件的常量池里。
  - 比如:描述一个方法调用了另外的其他方法时,就是通过常量池中指向方法的符号引用来表示的,那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。

![image-20220211152258170](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220211152258170.png)

#### 方法的调用

在JVM中,将符号引用转换为调用方法的直接引用与方法的绑定机制相关

- 静态链接
  当一个字节码文件被装载进JVM内部时,如果被调用的目标方法在编译期可知,且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。
- 动态链接:
  如果被调用的方法在编译期无法被确定下来,也就是说,只能够在程序运行期将调用方法的符号引用转换为直接引用,由于这种引用转换过程具备动态性,因此也就被称之为动态链接。

对应的方法的绑定机制为:早期绑定(Early Binding)和晚期绑定
( Late Binding)。绑定是一个字段、方法或者类在符号引用被替换为
直接引用的过程,这仅仅发生一次。

- 早期绑定
  早期绑定就是指被调用的目标方法如果在编译期可知,且运行期保持不变时,即可将这个方法与所属的类型进行绑定,这样一来,由于明确了被调用的目标方法究竟是哪一个,因此也就可以使用静态链接的方式将符号引用转换为直接引用。
- 晚期绑定
  如果被调用的方法在编译期无法被确定下来,只能够在程序运行期根据实际的类型绑定相关的方法,这种绑定方式也就被称之为晚期绑定。

随着高级语言的横空岀世,类似于java一样的基于面向对象的编程语言如今越来越多,尽管这类编程语言在语法风格上存在一定的差别,但是它们彼此之间始终保持着一个共性,那就是都支持封装、继承和多态等面向对象特性,既然这一类的编程语言**具备多态特性,那么自然也就具备早期绑定和晚期绑定**两种绑定方式。
Java中任何一个普通的方法其实都具备虚函数的特征,它们相当于C++语言中的虚函数(C++中则需要使用关键字 virtual来显式定义)。如果在Java程序中不希望某个方法拥有虚函数的特征时,则可以使用关键字final来标记这个方法。

方法的调用:虚方法与非虚方法

- 非虚方法
  如果方法在编译期就确定了具体的调用版本,这个版本在运行时是不可变的。这样的方法称为非虚方法。静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法
- 其他方法称为虚方法。

虚拟机中提供了以下几条方法调用指令:

- 普通调用指令:
- 1. invoke static:调用静态方法,解析阶段确定唯一方法版本![image-20220211161929673](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220211161929673.png)
  2. invoke special:调用<init>方法、私有及父类方法,解析阶段确定唯一方法版本![image-20220211161919014](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220211161919014.png)
  3. invoke virtual:调用所有虚方法![image-20220211161905880](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220211161905880.png)
  4. invoke interface:调用接口方法![image-20220211161834971](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220211161834971.png)
- 动态调用指令:
- 1. invoke dynamic:动态解析出需要调用的方法,然后执行前四条指令固化在虚拟机内部,方法的调用执行不可人为干预,而 invoke dynamic指令则支持由用户确定方法版本。其中 invoke static指令和 invoke special指令调用的方法称为非
     虚方法,其余的(fina1修饰的除外)称为虚方法。
- JVM字节码指令集一直比较稳定,一直到Java7中才增加了一个dynamic指令,这是Java为了实现「动态类型语言」支持而做的一种改进。
- 但是在Java7中并没有提供直接生成 invokedynamic指令的方法,需要借助，ASM这种底层字节码工具来产生 invokedynamic指令。直到Java8的 Lambda表达式的出现, invokedynamic指令的生成,在Java中才有了直接的生成方式
- Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改,而不是对Java语言规则的修改,这一块相对来讲比较复杂,增加了虚拟机中的方法调用,最直接的受益者就是运行在Java平台的动态语言的编译器。![image-20220211163030330](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220211163030330.png)



方法的调用:方法重写的本质
	Java语言中方法重写的本质:

1. 找到操作数栈顶的第一个元素所执行的对象的实际类型,记作C。
2. 如果在过程结束;如果不通过类型C中找到与常量中的描述符合简单名称都相符的方法则进行访问权限校验,如果通过则返回这个方法的直接引用,查找不通过,则返回
   java.lang.illegalAccesserror异常。
3. 否则,按照继承关系从下往上依次对c的各个父类进行第2步的搜索和验证过程。
4. 如果始终没有找到合适的方法,则抛出java.lang.AbstractMethodError异常。

**illegalAccessError介绍:**
程序试图访问或修改一个属性或调用一个方法,这个属性或方法,你没有权限访问。一般的,这个会引起编译器异常。这个错误如果发生在运行时,就说明一个类发生了不兼容的改变。

**方法的调用:虚方法表**
在面向对象的编程中,会很频繁的使用到动态分派,如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此,为了提高性能,JVM采用在类的方法区建立一个虚方法表( virtual method table)(非虚方法不会出现在表中)来实现。使用索引表来代替查找。每个类中都有一个虚方法表,表中存放着各个方法的实际入口。
**那么虚方法表什么时候被创建?**
虚方法表会在**类加载的链接阶段**被创建并开始初始化,类的变量初始值准备完成之后,JVM会把该类的虚方法表也初始化完毕。

#### 方法返回地址 (return address)

- 存放调用该方法的pc寄存器的值。
- 一个方法的结束,有两种方式
  - 正常执行完成
  - 出现未处理的异常,非正常退出
- 无论通过哪种方式退出,在方法退出后都返回到该方法被调用的位置。方法正常退出时,调用者的pc计数器的值作为返回地址,即调用该方法的指令的下一条指令的地址。而通过异常退出的,返回地址是要通过异常表来确定,栈帧中一般不会保存这部分信  息。

本质上,方法的退出就是当前栈帧出栈的过程。此时,需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等,让调用者方法继续执行下去。
**正常完成出口和异常完成出口的区别在于:通过异常完成出口退出的不会给他的上层调用者产生任何的返回值**。

当一个方法开始执行后,只有两种方式可以退出这个方法:

1. 执行引擎遇到任意一个方法返回的字节码指令( return),会有返回值传递给上层的方法调用者,简称正常完成出口;
   1. 一个方法在正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定。
   2. 在字节码指令中,返回指令包含 ireturn(当返回值是 boolean、byte、char、short和int类型时使用)、lreturn、 freturn、dreturn以及 areturn(引用类型),另外还有一个 return指令供声明为void的方法、实例初始化方法、类和接口的初始化方法使用
2. 在方法执行的过程中遇到了异常( Exception),并且这个异常没有在方法内进行处理预定也就是只要在本方法的异常表中没有搜索到匹配的异常处理器,就会导致方法退出。简称**异常完成出口。**
   方法执行过程中抛出异常时的异常处理,存储在一个异常处理表,方便在发生异常的时候找到处理异常的代码。

#### 虚拟机栈的面试题

- 举例栈溢出的情况?( StackOverflowError)
  - 通过-Xss设置栈的大小;OOM
- 调整栈大小,就能保证不出现溢出吗?不能
- 分配的栈内存越大越好吗?不是
- 垃圾回收是否会涉及到虚拟机栈?不会的
- 方法中定义的局部变量是否线程安全?具体情况具体讨论

### 本地方法接口

#### 什么是本地方法?

- 简单地讲一个 Native Method就是一个Java调用非Java代码的接口。一个Native Method是这样一个Java方法:该方法的实现由非Java语言实现,比如C。这个特征并非Java所特有,很多其它的编程语言都有这一机制,比如在C++中,你可以用 extern"c"告知C++编译器去调用一个C的函数。

- A native method is a Java method whose implementation is
  provided by non-java code

- 在定义一个 native method时,并不提供实现体(有些像定义一个Java interface),因为其实现体是由非java语言在外面实现的。
  本地接口的作用是融合不同的编程语言为Java所用,它的初衷是融合C/C+程序。

- ```java
  public class NativeTest01 {
      public native void Native1(int x);
  
      public native static long Native2();
  
      private native synchronized float Native3(Object o);
  
      native void Native4(int[] any) throws Exception;
  }
  ```

- 标识符 native可以与所有其它的java标识符连用,但是 abstract除外。

##### 为什么要使用 Native Method?

​	Java使用起来非常方便,然而有些层次的任务用Java实现起来不容易,或者我们对程序的效率很在意时,问题就来了。
​	**与Java环境外交互:**
​	有时Java应用需要与Java外面的环境交互,这是本地方法存在的主要原因。你可以想想Java需要与一些底层系统,如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制:它为我们提供了一个非常简洁的接口,而且我们无需去了解Java应用之外的繁琐的细节。

##### 现状

目前该方法使用的越来越少了,除非是与硬件有关的应用,比如通过
Java程序驱动打印机或者Java系统管理生产设备,在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达,比如可以使用 Socket通信,也可以使用 Web service等等,不多做介绍。

### 本地方法栈( Native Method Stack)

- Java虚拟机栈用于管理Java方法的调用,而本地方法栈用于管理本地方法的调用。
- 本地方法栈,也是线程私有的
- 允许被实现成固定或者是可动态扩展的内存大小。(在内存溢出方面是相同)如果线程请求分配的栈容量超过本地方法栈允许的最大容量,Java虚拟机将会抛出一个 stackoverflowError异常。
- 如果本地方法栈可以动态扩展,并且在尝试扩展的时候无法申请到足够的内存,或者在创建新的线程时没有足够的内存去创建对应的本地方法栈,那么Java虚拟机将会抛出一个 outofmemoryerror异常。
- 本地方法是使用C语言实现的。它的具体做法是 Native method stack中登记 native方法,在Execution Engine执行时加载本地方法库。

- 当某个线程调用一个本地方法时了它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有样的权限。
  - 本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区。
  - 它甚至可以直接使用本地处理器中的寄存器
  - 直接从本地内存的堆中分配任意数量的内存。
- 并不是所有的J都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持 native方法,也可以无需实现本地方法栈。
- 在 Hotspot JVM中,直接将本地方法栈和虚拟机栈合二为一。

![image-20220212120503876](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220212120503876.png)

## 四.堆

### 1.堆的核心概述

- 一个JVM实例只存在一个堆内存,堆也是Java内存管理的核心区域。
- Java堆区在JVM启动的时候即被创建,其空间大小也就确定了。是JVM管理的最大一块内存空间。
  - 堆内存的大小是可以调节的。
- 《Java虚拟机规范》规定,堆可以处于物理上不连续的內存空间中,但在逻辑上它应该被视为连续的
- 所有的线程共享Java堆,在这里还可以划分线程私有的缓冲区( Thread Local, Allocation Buffer, TLAB)
- 《Java虚拟机规范》中对Java堆的描述是:所有的对象实例以及数组都应当在运行时分配在堆上。( The heap is the run- time data area from which memory for all class instances and arrays is allocated)
  - 我要说的是:“几乎”所有的对象实例都在这里分配内存。从实际使用角度看的。
- 数组和对象可能永远不会存储在栈上,因为栈帧中保存引用,这个引用指向对象或者数组在堆中的位置。
- 在方法结束后,堆中的对象不会马上被移除,仅仅在垃圾收集的时候才会被移除。
- 堆,是GC( Garbage Collection,垃圾收集器)执行垃圾回收的重点
  区域

![image-20220212123825515](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220212123825515.png)

#### 堆的核心概述:内存细分

现代垃圾收集器大部分都基于分代收集理论设计,堆空间细分为

- Java7及之前堆内存逻辑上分为三部分:新生区+养老区+永久区
  - Young Generation Space新生区   Young/New
    - 又被划分为Eden区和 Survivor区
  - Tenure generation space养老区   old/Tenure
  - Permanent Space    永久区   Perm
- Java8及之后堆内存逻辑上分为三部分:新生区+养老区+元空间
  - Young Generation Space  新生区  Young/New
    - 又被划分为Eden区和 Survivor区
  - Tenure generation space  养老区   Old/Tenure
  - Meta Space                 元空间        Meta
- 约定:新生区<=>新生代<=>年轻代  养老区<=>老年区<=>老年代  永久区<=>永久代

### 2.设置堆内存大小和OOM

Java堆区用于存储Java对象实例,那么堆的大小在JVM启动时就已经设定好了,大家可以通过选项〃-Xmx和〃-Xms"来进行设置。
>- “-Xms用于表示堆区的起始内存,等价于-xx: InitialHeapsize
>  - -X是JVM运行参数
>  - ms: memory start
>- “-Xmx”则用于表示堆区的最大内存,等价于-Xx:MaxHeapsize
>- 一旦堆区中的内存大小超过“-Xmx"所指定的最大内存时,将会抛出Outofmemoryerror异常
>- 通常会将-Xms和-Xmx两个参数配置相同的值,其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小,从而提高性能。
>
>- 默认情况下,初始内存大小:物理电脑内存大小/64
>- 最大内存大小:物理电脑内存大小/4

### 3.年轻代与老年代

- 存储在JVM中的Java对象可以被划分为两类:
  - 一类是生命周期较短的瞬时对象,这类对象的创建和消亡都非常迅速
  - 另外一类对象的生命周期却非常长,在某些极端的情况下还能够与JVM的生命周期保持一致
- Java堆区进一步细分的话,可以划分为年轻代( YoungGen)和老年代( OldGen)
- 其中年轻代又可以划分为Eden空间、 Survivor0空间和Survivor1空间(有时也叫做from区、to区)。
- ![image-20220212142445273](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220212142445273.png)

![image-20220212142525377](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220212142525377.png)

配置新生代与老年代在堆结构的占比。

- 默认-XX: NewRatio=2,表示新生代占1,老年代占2,新生代占整个堆的1/3
- 可以修改-XX: Newratio=4,表示新生代占1,老年代占4,新生代占整个堆的1/5

- 在 Hotspot中,Eden空间和另外两个 Survivor空间缺省所占的比例是8:1:1
- 当然开发人员可以通过选项“-XX: Survivorratio”调整这个空间比例。比如-XX: SurvivorRatio=8
- 几乎所有的Java对象都是在Eden区被new出来的
- 绝大部分的Java对象的销毁都在新生代进行了。
- IBM公司的专门研究表明,新生代中80%的对象都是“朝生夕死”的
  可以使用选项〃-Xmn"设置新生代最大内存大小这个参数一般使用默认值就可以了
- ![image-20220212143723963](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220212143723963.png)

### 4. 对象分配过程:概述

为新对象分配内存是一件非常严谨和复杂的任务,JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题,并且由于内存分配算法与内存回收算法密切相关,所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。

1. new的对象先放伊甸园区。此区有大小限制
2. 当伊甸园的空间填满时,程序又需要创建对象,JVM的垃圾回收器将对伊甸园区进行垃圾回收( YGC/Minor GC),将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区然后将伊甸园中的剩余对象移动到幸存者0(survivor0)区。![image-20220212144220589](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220212144220589.png)
3. 如果再次触发垃圾回收,此时上次幸存下来的放到幸存者0区的,如果没有回收,就会放到幸存者1区。![image-20220212144301175](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220212144301175.png)
4. 如果再次经历垃圾回收,此时会重新放回幸存者0区,接着再去幸存者1区
5. 啥时候能去养老区呢?可以设置次数。**默认是15次**
   可以设置参数:-XX: MaxTenuringThreshold=<N>进行设置 ![image-20220212144422570](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220212144422570.png)
6. **针对幸存者s0,s1区的总结:复制之后有交换,谁空谁是to**
   **关于垃圾回收:频繁在新生区收集,很少在养老区收集,几乎不在永久区/元空间收集。**

![image-20220212144909347](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220212144909347.png)



常用调优工具
JDK命令行
Eclipse: Memory Analyzer Tool
Jconsole
VisualVM
Jprofiler
Java Flight Recorder
GC Viewer
GC Easy

### 5.Minor GC、 Major GC与Full GC

JVM在进行GC时,并非每次都对上面三个内存区域一起回收的,大部分时候回收的都是指新生代。
针对 Hotspot VM的实现,它里面的GC按照回收区域又分为两大种类型:一种是部分收集(Partial GC)，一种是整堆收集(Full GC)

- 部分收集:不是完整收集整个Java堆的垃圾收集。其中又分为
  - 新生代收集( Minor gc/ Young GC):只是新生代的垃圾收集
  - 老年代收集( Major GC/ Old GC):只是老年代的垃圾收集。
    - 目前,只有 CMS GC会有单独收集老年代的行为
    - 注意,很多时候 Major GC会和Full Gc混淆使用,需要具体分辨是老年代回收还是整堆回收。
  - 混合收集( Mixed GC):收集整个新生代以及部分老年代的垃圾收集。
    - 目前,只有G1 GC会有这种行为
- 整堆收集(Full GC):收集整个java堆和方法区的垃圾收集。

#### 年轻代GC( Minor GC)触发机制-

- 当年轻代空间不足时,就会触发 Minor GC,这里的年轻代满指的是Eden代满, Survivor满不会引发GC。(每次 Minor GC会清理年轻代的内存。)
- 因为Java对象大多都具备朝生夕灭的特性,所以 Minor GC非常频
  繁,一般回收速度也比较快。这一定义既清晰又易于理解
- Minor GC会引发STW,暂停其它用户的线程,等垃圾回收结束,用户线程才恢复运行。
- ![image-20220212150941430](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220212150941430.png)

#### 老年代GC( Major GC/Full GC)触发机制

- 指发生在老年代的GC,对象从老年代消失时,我们说“ Major GC”或“Full GC发生了。
- 出现了 Major GC,经常会伴随至少一次的 Minor GC(但非绝对的,在Parallel Scavenge收集器的收集策略里就有直接进行 Major GC的策略选择过程)，也就是在老年代空间不足时,会先尝试触发 Minor GC。如果之后空间还不足,则触发 Mayor GC
- Major GC的速度一般会比 Minor GC慢10倍以上,STW的时间更长。
- 如果 Major GC后,内存还不足,就报OOM了。

#### Full Gc触发机制:(后面细讲)

- 触发Full GC执行的情况有如下五种
  1. 调用 System.gc()时,系统建议执行FullGC,但是不必然执行
  2. 老年代空间不足
  3. 方法区空间不足
  4. 通过 Minor gc后进入老年代的平均大小大于老年代的可用内存
  5. 由Eden区、 survivor spaceθ( From Space)区向 survivor space1(To Space)区复制时,对象大小大于 To Space可用内存,则把该对象转存到老年代,且老年代的可用内存小于该对象大小
- 说明:full gc是开发或调优中尽量要避免的。这样暂停时间会短一些

### 6.堆空间分代思想

**为什么需要把Java堆分代?不分代就不能正常工作了吗?**

- 经研究,不同对象的生命周期不同。70%-99%的对象是临时对象。
  - 新生代:有Eden、两块大小相同的 Survivor(又称为from/to,s0/s1)构成,to总为空。
  - 老年代:存放新生代中经历多次GC仍然存活的对象。
- 其实不分代完全可以,分代的唯一理由就是优化GC性能。如果没有分代,那所有的对象都在一块,就如冋把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的,如果分代的话,把新创建的对象放到某一地方,当GC的时候先把这块存储“朝生夕死”对象的区域进行回收,这样就会腾出很大的空间出来。

### 7.内存分配策略(对象提升规则Promotion)

如果对象在Eden出生并经过第一次 Minor GC后仍然存活,并且能被 Survivor容纳的话,将被移动到 Survivor空间中,并将对象年龄设为1。对象在Survivor区中每熬过一次 Minora,年龄就增加1岁,当它的年龄增加到一定程度(默认为15岁,其实每个JVM、每个GC都有所不同)时,就会被晋升到老年代中
对象晋升老年代的年龄阈值,可以通过选-XX:MaxTenuringThreshold来设置

针对不同年龄段的对象分配原则如下所示

1. 优先分配到Eden
2. 大对象直接分配到老年代
   1. 尽量避免程序中出现过多的大对象
3. 长期存活的对象分配到老年代
4. 动态对象年龄判断
   如果 Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半,年龄大于或等于该年龄的对象可以直接进入老年代,无须等到MaxTenuringThreshold中要求的年龄。
5. 空间分配担保
   1. -XX: HandlePromotionFailure

### 8.为对象分配内存:TLAB

#### 为什么有TLAB( Thread local Allocation Buffer)?

- 堆区是线程共享区域,任何线程都可以访问到堆区中的共享数据
- 由于对象实例的创建在JM中非常频繁,因此在并发环境下从堆区中划分内存空间是线程不安全的
- 为避免多个线程操作同一地址,需要使用加锁等机制,进而影响分配速度

#### 什么是TLAB?

- 从内存模型而不是垃圾收集的角度,对Eden区域继续进行划分,JVM为每个线程分配了一个私有缓存区域,它包含在Eden空间内。
- 多线程同时分配内存时,使用TLAB可以避兔一系列的非线程安全问题,同时还能够提升内存分配的吞吐量,因此我们可以将这种内存分配方式称之为快速分配策略
- 所有 openJDK衍生出来的JVM都提供了TLAB的设计

#### TLAB的再说明:

- 尽管不是所有的对象实例都能够在TLAB成功分配内存,但JVM确实是将TLAB作为内存分配的首选。
- 在程序中,开发人员可以通过选项“-XX: UseTlAB”设置是否开启TLAB空间。
- 默认情况下,TLAB空间的内存非常小,仅占有整个Eden空间的1%,当然我们可以通过选项“-XX: TLABWastetargetPercent”设置TLAB空间所占用Eden空间的百分比大小。
  ·
- 一旦对象在TLAB空间分配内存失败时,JVM就会尝试着通过使用加锁机制确保数据操作的原子性,从而直接在Eden空间中分配内存。
- ![image-20220212154020747](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220212154020747.png)

### 9.堆空间常用参数

- -XX:+ PrintFlagsInitial:查看所有的参数的默认初始值
- -XX:+ PrintFlagsFinal:查看所有的参数的最终值(可能会存在修改,不再是初始值)
- -Xms:初始堆空间内存(默认为物理内存的1/64)
- -Xmx:最大堆空间内存(默认为物理内存的1/4)
- -Xmn:设置新生代的大小。(初始值及最大值)
- -XX:NewRatio:配置新生代与老年代在堆结构的占比 
- -XX:SurvivorRatio:设置新生代中Eden和S0/S1空间的比例
- -XX: MaxTenuringThreshold:设置新生代垃圾的最大年龄
- -XX:+ PrintGCDetails:输出详细的GC处理日志
- 打印gc简要信息:①-XX:+Prints②-verbose:gc
- -XX:HandlePromotionFailure:是否设置空间分配担保

### 10.堆是分配对象存储的唯一选择吗？

堆是分配对象存储的唯一选择吗?

- 在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述
  随着JIT编译期的发展与**逃逸分析技术**逐渐成熟,**栈上分配**、**标量替换优化技术**将会导致一些微妙的变化,所有的对象都分配到堆上也渐渐变得不那么“绝对”了。
- 在Java虚拟机中,对象是在Java堆中分配内存的,这是一个普遍的常识。但是,有种特殊情况,那就是如果经过逃逸分析( Escape Analysis)后发现,一个对象并没有逃逸出方法的话,那么就可能被优化成栈上分配。这样就无需在堆上分配内存,也无须进行垃圾回收了。这也是最常见的堆外存储技术。
- 此外,前面提到的基于 OpenJDK深度定制的 TaobaoVM,其中创新的 GCIH(GC invisible heap)技术实现off-heap,将生命周期较长的Java对象从heap中移至heap外,并且GC不能管理GCIH内部的Java对象,以此达到降低GC的回收频率和提升GC的回收效率的目的。

#### 逃逸分析概述

```java
package com.example.Heap;

/**
 * author ye
 * createDate 2022/2/13  11:19
 * 如何快速的判断是否发生了逃逸分析,大家就看new的对象是否有可能在方法外被调用
 */
public class EscapeAnalysis {
    public EscapeAnalysis obj;
    /**
     * 方法返回EscapeAnalysis对象，发生逃逸
     */
    public EscapeAnalysis getInstance(){
        return obj == null ? new EscapeAnalysis() : obj;
    }
    /**
     * 为成员属性，发生逃逸
     */
    public void setObj(){
        this.obj = new EscapeAnalysis();
    }
    /**
     * 对象的作用域仅在当前方法中有效，没有发生逃逸
     */
    public void useEscapeAnalysis(){
        EscapeAnalysis e = new EscapeAnalysis();
    }
    /**
     * 引用成员变量的值，发生逃逸
     */
    public void useEscapeAnalysis2(){
        EscapeAnalysis e = getInstance();
        //getInstance().xxx()同样会发生逃逸
    }
}
```



没有发生逃逸的对象,则可以分配到栈上,随着方法执行的结束,栈空间
就被栘除。

选项“-XX:+DoEscapeAnalysis"显式开启逃逸分析: 默认开启

-XX:-DoEscapeAnalysis 关闭

通过选项“-XX:+PrintEscapeAnalysis"查看逃逸分析的筛
选结果。

结论:
开发中能使用局部变量的,就不要使用在方法外定义

使用逃逸分析,编译器可以对代码做如下优化:

- 栈上分配。将堆分配转化为栈分配。如果一个对象在子程序中被分配,要使指向该对象的指针永远不会逃逸,对象可能是栈分配的候选,而不是堆分配
- 同步省略。如果一个对象被发现只能从一个线程被访问到,那么对于这个对象的操作可以不考虑同步
  - 线程同步的代价是相当高的,同步的后果是降低并发性和性能
  - 在动态编译同步块的时候,JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有,那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略,也叫**锁消除**
- 分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构有在也可以被访问到,那么对象的部分(或全部)可以不存储在内存,而是有储在CPU寄存器中。
  - 标量( Scalar)是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。
  - 相对的,那些还可以分解的数据叫做聚合量( Aggregate),Java中的对象就是聚合量,因为他可以分解成其他聚合量和标量。
  - 在JIT阶段,如果经过逃逸分析,发现一个对象不会被外界访问的话,那么经过JIT优化,就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。
  - 标量替换参数设置:
    参数-ⅩX:+ EliminateAllocations:开启了标量替换(默认打
    开),允许将对象打散分配在栈上。

逃逸分析小结:逃逸分析并不成熟

- 关于逃逸分析的论文在1999年就已经发表了,但直到JDK1.6才有实现,而且这项技术到如今也并不是十分成熟的。
- 其根本原因就是无法保证逃逸分析的性能消耗一定能髙于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的,这其实也是一个相对耗时的过程。
- 举个极端的例子,就是经过逃逸分析之后,发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。
- 虽然这项技术并不十分成熟,但是它也是即时编译器优化技术中一个十分重要的手段。
  注意到有一些观点,认为通过逃逸分析,JVM会在栈上分配那些不会逃逸的对象,这在理论上是可行的,但是取决于JⅥM设计者的选择。
- 据我所知, oracle Hotspot JVM中并未这么做,这一点在逃逸分析相关的文档里已经说明,所以可以明确所有的对象实例都是创建在堆上。
- 目前很多书籍还是基于JDK7以前的版本,JDK已经发生了很大变化, intern字符串的缓存和静态变量曾经都被分配在永久代上,而永久代已经被元数据区取代。但是,intern字符串缓存和静态变量并不是被转移到元数据区,而是直接在堆上分配,所以这一点同样符合前面一点的结论:**对象实例都是分配在堆上**

### 小结

- 年轻代是对象的诞生、成长、消亡的区域,一个对象在这里产生、应用,最后被垃圾回收器收集、结束生命
- 老年代放置长生命周期的对象,通常都是从 Survivor区域筛选拷贝过来的Java对象。当然,也有特殊情况,我们知道普通的对象会被分配在TLAB上;如果对象较大,JVM会试图直接分配在Eden其他位置上;如果对象太大,完全无法在新生代找到足够长的连续空闲空间,JVM就会直接分配到老年代
- 当GC只发生在年轻代中,回收年轻代对象的行为被称为 Minor GC。当GC发生在老年代时则被称为 Major GC或者Full GC。一般的, Mino GC的发生频率要比 Major GC高很多,即老年代中垃圾回收发生的频率将大大低于年轻代。

---

## 五.方法区

### 运行时数据区结构图

![image-20220213115304690](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220213115304690.png)

### 栈、堆、方法区的交互

![image-20220213115340019](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220213115340019.png)

![image-20220213115500955](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220213115500955.png)

### 2.方法区的理解

方法区在哪里?
《Java虚拟机规范》中明确说明:尽管所有的方法区在逻辑上是属于堆的一部分,但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于 HotSpot JVM而言,方法区还有一个别名叫做Non-Heap(非堆),目的就是要和堆分开。所以,**方法区看作是一块独立于Java堆的内存空间。**

方法区的基本理解

- 方法区( Method area)与Java堆一样,是各个线程共享的内存区域。
- 方法区在JVM启动的时候被创建,并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的
- 方法区的大小,限堆空间一样,可以选择固定大小或者可扩展。
  方法区的大小决定了系统可以保存多少个类,如果系统定义了太多的类,导致方法区溢出,虚拟机同样会抛出内存溢出错误:java.lang.OutOfMemoryError:**PermGen space** 或 java. lang.OutOfMemoryError: **Meta space**，关闭JVM就会释放这个区域的内存。

### 3.设置方法区大小与OOM

-XX:MetaspaceSize 初始值

-XX:MaxMetaspaceSize 最大值

window下默认初始值21M

最大值 -1 表示无上限

```
C:\Users\YQ>jps
14720 Jps
7540 Launcher
2248
10748 MetaSpaceTest01

C:\Users\YQ>jinfo -flag MetaspaceSize 10748
-XX:MetaspaceSize=21807104

C:\Users\YQ>
```

如何解决这些OOM?

1. 要解决OOM异常或 heap space的异常,一般的手段是首先通过内存映像分析工具(如Eclipse Memory Analyzer)对dump出来的堆转储快照进行分析,重点是确认内存中的对象是否是必要的,也就是要先分清楚到底是出现了内存泄漏( Memory leak)还是内存溢出( Memory Overflow)。
2. 如果是内存泄漏,可进一步通过工具査看泄漏对象到 GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与 GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息,以及 GC Roots引用链的信息,就可以比较准确地定位出泄漏代码的位置。
3. 如果不存在内存泄漏,换句话说就是内存中的对象确实都还必须存活着,那就应当检査虚拟机的堆参数(-Xmx与-Xms),与机器物理内存对比看是否还可以调大,从代码上检査是否存在某些对象生命周期过长、持有状态时间过长的情况,尝试减少程序运行期的内存消耗。

### 4.方法区的内存结构

![image-20220213123310701](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220213123310701.png)

它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。

![image-20220213123351104](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220213123351104.png)

类型信息
对每个加载的类型(类class、接口 interface、枚举enum、注解 annotation),JVM必须在方法区中存储以下类型信息:

1. 这个类型的完整有效名称(全名=包名.类名)
2. 这个类型直接父类的完整有效名(对于 interface或是java.lang. Object,都没有父类)
3. 这个类型的修饰符( public, abstract,final的某个子集)
4. 这个类型直接接口的一个有序列表

方法 (Method)信息
JVM必须保存所有方法的以下信息,同域信息一样包括声明顺序:

- 方法名称
- 方法的返回类型(或void)
- 方法参数的数量和类型(按顺序)
- 方法的修饰符( public, private, protected, static,final,
  synchronized, native, abstract的一个子集)
- 方法的字节码( bytecodes)、操作数栈、局部变量表及大小( abstract和native方法除外)
- 异常表( abstract和 native方法除外)
- 每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引

补充说明:全局常量: static final

- 被声明为fina的类变量的处理方法则不同,每个全局常量在编译的时候就会被分配了

#### 运行时常量池vs常量池

- 方法区,内部包含了运行时常量池
- 字节码文件,内部包含了常量池。

一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外,还包含一项信息那就是常量池表( Constant pool Table),包括各种字面量和对类型、域和方法的符号引用。

小结
常量池,可以看做是一张表,虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。

运行时常量池

- 运行时常量池( Runtime Constant pool)是方法区的一部分。
- 常量池表(constant pool Table)是Class文件的一部分,用于存放编译期生成的各种字面量与符号引用,这部分内容将在类加载后存放到方法区的运行时常量池中。
- 运行时常量池,在加载类和接口到虚拟机后,就会创建对应的运行时常量池。
- JVM为每个已加载的类型(类或接口)都维护一个常量池。池中的数据项像数组项一样,是通过索引访问的。
- 运行时常量池中包含多种不同的常量,包括编译期就已经明确的数值字面量,也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了,这里换为真实地址。
- 运行时常量池,相对于Class文件常量池的另一重要特征是:**具备动态性。**
- 运行时常量池类似于传统编程语言中的符号表( symbol table),但是它所包含的数据却比符号表要更加丰富一些。
- 当创建类或接口的运行时常量池时,如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值,则JVM会抛 OutOfMemoryError异常。

### 5.方法区举例

```java
public class MetaSpaceDome {
    public static void main(String[] args) {
        int x = 500;
        int y = 800;
        int a = x / y;
        int b = 50;
        System.out.println(a + b);
    }
}
public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=3, locals=5, args_size=1
         0: sipush        500
         3: istore_1
         4: sipush        800
         7: istore_2
         8: iload_1
         9: iload_2
        10: idiv
        11: istore_3
        12: bipush        50
        14: istore        4
        16: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
        19: iload_3
        20: iload         4
        22: iadd
        23: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V
        26: return
```



### 6.方法区的演进细节

1. 首先明确:只有 Hotspot才有永久代。
   BEA JRockit、IBM ]9等来说,是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节,不受《Java虚拟机规范》管束,并不要求统一
2. Hotspot中方法区的变化
   - jak16及之前有永久代( Permanent generation),静态变量存放在永久代上
   - jakl. 7有永久代,但已经逐步“去永久代”,字符串常量池、静
     态变量移除,保存在堆中
   - jdk18及之后无永久代,类型信息、字段、方法、常量保存在本地内存的元空间,但字符串常量池、静态变量仍在堆

String Table为什么要调整?
jdk7中将 StringTable放到了堆空间中。因为永久代的回收效率很低,在full gc的时候才会触发。而full gc是老年代的空间不足、永久代不足时才会触发。这就导致 Stringtable回收效率不高。而我们开发中会有大量的字符串被创建,回收效率低,导致永久代内存不足。放到堆里,能及时回收内存。

### 7.方法区的垃圾回收

方法区的垃圾收集主要回收两部分内容:常量池中废弃的常量和不再使用的类型

- 先来说说方法区内常量池之中主要存放的两大类常量:字面量和符号引用字面量比较接近Java语言层次的常量概念,如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念,包括下面三类常量:

1. 类和接口的全限定名
2. 字段的名称和描述符
3. 方法的名称和描述符

- HotSpot虚拟机对常量池的回收策略是很明确的,**只要常量池中的常量没有被任何地方引用,就可以被回收**
- 回收废弃常量与回收]ava堆中的对象非常类似

- 判定一个常量是否“废弃”还是相对简单,而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件:
  - 该类所有的实例都已经被回收,也就是Java堆中不存在该类及其任何派生子类的实例。
  - 加载该类的类加载器已经被回收,这个条件除非是经过精心设计的可替换类加载器的场景,如OSGi、JSP的重加载等,否则通常是很难达成的。
  - 该类对应的java.lang.Class对象没有在任何地方被引用,无法在任何地方通过反射访问该类的方法。
- Java虚拟机被允许对满足上述三个条件的无用类进行回收,这里说的仅仅是“被允许”,而并不是和对象一样,没有引用了就必然会回收。关于是否要对类型进行回收,Hotspot虚拟机提供了                            ,-Xnoclassgc参数进行控制,还可以使用- verbose:class以及
  -XX:+Traceclass- Loading、-XX:+TraceClassUnLoading查看类加载和卸载信息
- 在大量使用反射、动态代理、 CGLib等字节码框架,动态生成JSP以及OSGi这类频繁自定义类加载器的场景中,通常都需要Java虚拟机具备类型卸载的能力,以保证不会对方法区造成过大的内存压力。

### 总结

![image-20220213140334945](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220213140334945.png)

## 六.对象实例化内存布局与访问定位

### 1.对象的实例化

#### 创建对象的步骤

1. 判断对象对应的类是否加载、链接、初始化
   1. 虚拟机遇到一条new指令,首先去检查这个指令的参数能否在 Meta space的常量池中定位到一个类的符号引用,并且检查这个符号引用代表的类是否已经被加载、解析和初始化。(即判断类元信息是否存在)。如果没有,那么在双亲委派模式下,使用当前类加载器以 Class loader+包名+类名为Key进行查找对应的class文件。如果没有找到文件,则抛出 Class Not Found Exception异常如果找到,则进行类加载,并生成对应的class类对象
2. 为对象分配内存; 首先计算对象占用空间大小,接着在堆中划分一块内存给新对象如果实例成员变量是引用变量,仅分配引用变量空间即可,即4个字节大小
   1. 如果内存规整
      1. 指针碰撞目:如果内存是规整的,那么虚拟机将采用的是指针碰撞法( Bump The Pointer)来为对象分配内存意思是所有用过的内存在一边,空闲的内存在另外一边,中间放着一个指针作为分界点的指示器,
         分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是 Serial、 ParNew这种基于压缩算法的,虛拟机采用这种分配方式。一般使用带有compact(整理)过程的收集器时,使用指针碰撞虚拟机
   2. 如果内存不规整
      1. 需要维护一个列表
      2. 空闲列表分配:  如果内存不是规整的,已使用的内存和未使用的内存相互交错,那么虚拟机将采用的是空闲列表法
         来为对象分配内存。
         意思是虚拟机维护了一个列表,记录上哪些内存块是可用的,再分配的时候从列表中找到一块足够
         大的空间划分给对象实例,并更新列表上的内容。这种分配方式成为“空闲列表( Free List)"。
      3. 说明: 选择哪种分配方式由Java堆是否规整决定,而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定
   3. 处理并发安全问题
      1. 采用CAS失败重试,区域加锁保证更新的原子性
      2. 每个线程预先分配一块TLAB
3. 初始化分配到的空间
4. 所有属性设置默认值,保证对象实例字段在不赋值时可以直接使用
5. 设置对象的对象头:  将对象的所属类(即类的元数据信息)、对象的 HashCode和对象的GC信息、锁信息等数据存储
   在对象的对象头中。这个过程的具体设置方式取决于JVM实现
6.  执行<init>方法进行初始化: 在Java程序的视角看来,初始化才正式开始。初始化成员变量,执行实例化代码块,调用类的构造方法,并把堆内对象的首地址赋值给引用变量
   因此一般来说(由字节码中是否跟随有 invokespecia指令所决定),new指令之后会接着就是执行方法,把对象按照程序员的意愿进行初始化,这样一个真正可用的对象才算完全创建出来

### 2.对象内存布局

1. 对象头( Header) ; 包含两部分
   1. 运行时数据（Mark Data)
      - 哈希值( HashCode)
      - GC分代年龄
      - 锁状态标志
      - 线程持有的锁
      - 偏向线程ID
      - 偏向时间戳
   2. 类型指针------指向元数据(InstanceKlass)，确定该对象所属的类型
   3. 如果是数组，还需记录数组的长度
2. 实例数据( instance data)
   - 说明—它是对象真正存储的有效信息,包括程序代码中定义的各种类型的字段(包括从父类继承下来的和本身拥有的字段)
   - 规则
     - 相同宽度的字段总是被分配在一起
     - 父类中定义的变量会出现在子类之前
     - 如果 Compact Fields参数为true(默认为true):子类的窄变量可能插入到父类变量的空隙
3. 对齐填充( Padding)
   - 不是必须的,也没特别含义,仅仅起到占位符的作用
4. 小结![image-20220213154749070](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220213154749070.png)

### 3.对象的访问定位

JVM是如何通过栈帧中的对象引用访问到其内部的对象实例的呢?

![image-20220213154849691](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220213154849691.png)

- 句柄访问![image-20220213155005288](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220213155005288.png)
- 直接指针(Hospot采用)![image-20220213155105325](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220213155105325.png)

## 七.直接内存

### 直接内存概述

- 不是虚拟机运行时数据区的一部分,也不是《Java虚拟机规范》中定义的内存区域。
- 直接内存是在Java堆外的、直接向系统申请的内存区间。
- 来源于NIO,通过存在堆中的 DirectByteBuffer操作 Native内存
- 通常,访问直接内存的速度会优于Java堆。即读写性能高。
  - 因此出于性能考虑,读写频繁的场合可能会考虑使用直接内存
  - Java的NIO库允许Java程序使用直接内存,用于数据缓冲区

读写文件,需要与磁盘交互需要由用户态切换到内核态。
在内核态时,需要内存如右图的操作。使用IO,见右图。这里需要
两份内存存储重复数据,效率低

![image-20220213160052476](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220213160052476.png)

使用NIO时,如右图。操作系统划出的直接缓存区可以被java代码直接访问,只有一份。NIO适合对大文件的读写操作

![image-20220213160158844](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220213160158844.png)

- 也可能导致 OutOfMemoryError.异常
- 由于直接内存在Java堆外,因此它的大小不会直接受限于-Xmx指定的最大堆大小,但是系统内存是有限的,Java堆和直接内存的总和依然受限于操作系统能给出的最大内存。
- 缺点
  - 分配回收成本较高
  - 不受JVM内存回收管理
- 直接内存大小可以通过 MaxDirectMemorySize设置如果不指定,默认与堆的最大值-Xmx参数值一致

## 八.执行引擎

![image-20220214133407416](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220214133407416.png)

### 1.执行引擎概述

- 执行引擎是]ava虚拟机核心的组成部分之一。
- “虚拟机”是一个相对于“物理机”的概念,这两种机器都有代码执行
  能力,其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的,而虚拟机的执行引擎则是由软件自行实现的,因此可以不受物理条件制约地定制指令集与执行引擎的结构体系,能够执行那些不被硬件直接支持的指令集格式。

- JVM的主要任务是负责装载字节到其内部,但字节码并不能够直接运行在操作系统之上,因为字节码指令并非等价于本地机器指令,它内部包含的仅仅只是一些能够被JM所识别的字节码指令、符号表,以及其他辅助信息。
- 那么,如果想要让一个Java程序运行起来,执行引擎( Execution Engine)的任务就是将字节码指令解释/编译为对应平台上的本地机器指令才可以。简单来说,JVM中的执行引擎充当了将高级语言翻译为机器语言的译者

#### 执行过程

1. 执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全
   依赖于PC寄存器。
2. 每当执行完一项指令操作后,PC寄存器就会更新下一条需要被
   执行的指令地址。
3. 当然方法在执行的过程中,执行引擎有可能会通过存储在局部变
   量表中的对象引用准确定位到存储在Java堆区中的对象实例信息,以及通过对象头中的元数据指针定位到目标对象的类型信息。
4. ![image-20220214125801021](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220214125801021.png)

从外观上来看,所有的Java虚拟机的执行引擎输入、输出都是一致的:输入的是字节码二进制流,处理过程是字节码解析执行的等效过程,输出的是执行结果。

### 2.java代码编译和执行的过程

![image-20220214130001656](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220214130001656.png)

大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前,都需要经过上图中的各个步骤。

Java字节码的执行是由J执行引擎来完成,流程图如下所示

![image-20220214130220841](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220214130220841.png)

问题:什么是解释器( Interpreter),什么是JT编译器?

- 解释器:当Java虛拟杋启动时会根据预定义的规范对字节码采用逐行解释的方式执行,将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。

- JIT( Just In Time Compiler)编译器:就是虚拟机将源代码直接编
  译成和本地机器平台相关的机器语言。

问题:为什么说Java是半编译半解释型语言?

- 现在w在执行Java代码的时候,通常都会将解释执行与编译执行二者结合起来进行。

### 3.机器码，指令，汇编语言

#### 机器码

- 各种用二进制编码方式表示的指令,叫做机器指令码。开始,人们就用它采编写程序,这就是机器语言。
- 机器语言虽然能够被计算机理解和接受,但和人们的语言差别太大,不易被人们理解和记忆,并且用它编程容易出差错。
- 用它编写的程序一经输入计算机,CPU直接读取运行,因此和其他语言编的程序相比,执行速度最快
- 机器指令与CPU紧密相关,所以不同种类的CPU所对应的机器指令也就不同。

#### 指令

- 由于机器码是有0和1组成的二进制序列,可读性实在太差,于是人们发明了指令。
- ·指令就是把机器码中特定的0和1序列,简化成对应的指令(一般为英文简写,如mov,in等),可读性稍好
- 由于不同的硬件平台,执行同一个操作,对应的机器码可能不同,所以不同的硬件平台的同一种指令(比如mov),对应的机器码也可能不同

#### 指令集

- 不同的硬件平台,各自支持的指令,是有差别的。因此每个平台所支持的指令,称之为对应平台的指令集如常见的x86指令集,对应的是x86架构的平台ARM指令集,对应的是ARM架构的平台

#### 汇编语言

- 由于指令的可读性还是太差,于是人们又发明了汇编语言。
- 在汇编语言中,用助记符( Mnemonics)代替机器指令的操作码,用地址符号( symbol )或标号(Labe1)代替指令或操作数的地址。
  在不同的硬件平台,汇编语言对应着不同的机器语言指令集,通过汇编过程转换成机器指令。
- 由于计算机只认识指令码,所以用汇编语言编写的程序还必须翻译成机器指令码,计算机才能识别和执行。

#### 高级语言

- 为了使计算机用户编程序更容易些,后来就出现了各种高级计算机语言。高级语言比机器语言、汇编语言更接近人的语言
- 当计算机执行高级语言编写的程序时,仍然需要把程序解释和编译成机器的指令码。完成这个过程的程序就叫做解释程序或编译程序。

![image-20220214131223265](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220214131223265.png)

#### 字节码

- 字节码是一种中间状态(中间码)的二进制代码(文件),它比机器码更抽象,需要直译器转译后才能成为机器码
- 字节码主要为了实现特定软件运行和软件环境、与硬件环境无关。
- 字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码,
- 特定平台上的虚拟机器将字节码转译为可以直接执行的指令。
  字节码的典型应用为Java bytecode
- ![image-20220214131500831](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220214131500831.png)

C、C++源程序执行过程

- 编译过程又可以分成两个阶段:编译和汇编。编译过程:是读取源程序(字符流),对之进行词法和语法的分析,将高级语言指
  令转换为功能等效的汇编代码
- 汇编过程:实际上指把汇编语言代码翻译
  成目标机器指令的过程。
- ![image-20220214131332114](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220214131332114.png)

### 4.解释器

JVM设计者们的初衷仅仅只是单纯地为**了满足Java程序实现跨平台特性**,因此避免采用静态编译的方式直接生成本地机器指令,从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法。

![image-20220214131739712](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220214131739712.png)

#### 解释器工作机制(或工作任务)

解释器真正意义上所承担的角色就是一个运行时“翻译者”,将字节
码文件中的内容“翻译”为对应平台的本地机器指令执行
当一条字节码指令被解释执行完成后,接着再根据PC寄存器中记录的
下一条需要被执行的字节码指令执行解释操作。

#### 解释器分类

- 在Java的发展历史里,一共有两套解释执行器,即古老的**字节码解释器**、现在普遍使用的**模板解释器。**
- 字节码解释器在执行时通过纯软件代码模拟字节码的执行,效率非常低下
- 而模板解释器将每一条字节码和一个摸板函数相关联,模板函数中直接产生这条字节码执行时的机器码,从而很大程度上提高了解释器的性能。
- 在 HotSpot JVM中,解释器主要由 Interpreter模块和code模块构成
  - Interpreter模块:实现了解释器的核心功能
  - code模块:用于管理 HotSpot JVM在运行时生成的本地机器指令

### 5.JIT编译器

#### Java代码的执行分类

第一种是将源代码编译成字节码文件,然后在运行时通过解释器将字节码文件转为机器码执行
第二种是编译执行(直接编译成机器码)。现代虚拟机为了提高执行效
率,会使用即时编译技术(JIT, Just in time)将方法编译成机器码后再执行

#### Hotspot JVM的执行方式

当虚拟机启动的时候,解释器可以首先发挥作用,而不必等待即时编译器全部编译完成再执行,这样可以省去许多不必要的编译时间。并且随着程序运行时间的推移,即时编译器逐渐发挥作用,根据热点探测功能,将有价值的字节码编译为本地机器指令,以换取更高的程序执行效率。

### JIT编译器

概念解释:

- Java语言的“编译期”其实是一段“不确定”的操作过程,因为它可能是指一个**前端编译器**(其实叫“编译器的前端”更准确一些)把java文件转变成.class文件的过程;
- 也可能是指虚拟机的**后端运行期编译器**(JIT编译器, Just In Time Compiler)把字节码转变成机器码的过程
- 还可能是指使用**静态提前编译器**(AOT编译器,Aheaα of Time Compiler)直接把.java文件编译成本地机器代码的过程。

### 热点代码及探测方式

当然是否需要启动JIT编译器将字节码直接编译为对应平台的本地机器指令,则需要根据代码被调用执行的频率而定。关于那些需要被编译为本地代码的字节码,也被称之为“热点代码”,JIT编译器在运行时会针对那些频繁被调用的“热点代码”做出深度优化,将其直接编译为对应平台的本地机器指令,以此提升Java程序的执行性能。

#### 热点代码及探测方式

- 一个被多次调用的方法,或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”,因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中,因此也被称之为栈上替换,或简称为OSR( On stack
  Replacement)编译。
- 一个方法究竟要被调用多少次,或者一个循环体究竟需要执行多少次循环才可以达到这个标准?必然需要一个明确的阈值,JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠热点探测功能
- 目前 Hotspot JVM所采用的热点探测方式是基于计数器的热点探测。
- 采用基于计数器的热点探测, Hotspot JVM将会为每一个方法都建立2个不同类型的计数器,分别为方法调用计数器( Invocation counter)和回边计数器(Back Edge Counter)
  - 方法调用计数器用于统计方法的调用次数
  - 回边计数器则用于统计循环体执行的循环次数

##### 方法调用计数器

- 这个计数器就用于统计方法被调用的次数,它的默认阈值在 Client模式下是1500次,在 Server模式下是10000次。超过这个阈值,就会触发JIT编译。
- 这个阈值可以通过虚拟机参数-XX:CompileThreshold来人为设定。
- 当一个方法被调用时,会先检査该方法是否存在被JIT编译过的版本,如果存在,则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本,则将此方法的调用计数器值加1,然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阈值。如果已超过阈值,那么将会向即时编译器提交一个该方法的代码编译请求。

![image-20220214133835608](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220214133835608.png)

###### 热度衰减

- 如果不做任何设置,方法调用计数器统计的并不是方法被调用的绝对次数,而是一个相对的执行频率,即一段时间之内方法被调用的次数。当超过一定的时间限度,如果方法的调用次数仍然不足以让它提交给即时编译器编译,那这个方法的调用计数器就会被减少一半,这个过程称为方法调用计数器热度的衰减( Counter Decay),而这段时间就称为此方法统计的半衰周期( Counter half life time)

- 进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的,可以使用虚拟机参数-XX:- UseCounterDecay来关闭热度衰减,让方法计数器统计方法调用的绝对次数,这样,只要系统运行时间足够长,绝大部分方法都会被编译成本地代码。
- 另外,可以使用-XX: CounterhalfLifeTime参数设置半衰周期的时间,单位是秒

##### 回边计数器

它的作用是统计一个方法中**循环体代码执行的次数**,在字节码中遇到控制流向后跳转的指令称为“回边”( Back edge)。显然,建立回边计数器统计的目的就是为了触发OSR编译。

![image-20220214134210707](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220214134210707.png)

### Hotspot JVM可以设置程序执行方式

缺省情况下 Hotspot JVM是采用解释器与即时编译器并存的架构,当然开发人员可以根据具体的应用场景,通过命令显式地为Java虚拟机指定在运行时到底是完全采用解释器执行,还是完全采用即时编译器执行。如下所示:

- -Xint:完全采用解释器模式执行程序
- -Xcomp:完全采用即时编译器模式执行程序。如果即时编译出现问题,解释器会介入执行。
- -Xmixed:采用解释器+即时编译器的混合模式共同执行程序。

![image-20220214134426108](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220214134426108.png)

### Hotspot JVM中JIT分类

在 Hot SpotⅦM中内嵌有两个JT编译器,分别为client Compiler和 Server Compiler,但大多数情况下我们简称为C1编译器和C2编译器。开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器,如下所示:

- -client:指定Java虚拟机运行在 Client模式下,并使用c1编译器
  - C1编译器会对字节码进行简单和可靠的优化,耗时短。以达到更快的编译速度
- -server:指定Java虚拟机运行在 Server模式下,并使用c2编译器。
  C2进行耗时较长的优化,以及激进优化。但优化的代码执行效率更高

### C1和C2编译不同的优化策略:

- 在不同的编译器上有不同的优化策略,C1编译器上主要有方法内联,去虚拟化、冗余消除。
  - 方法内联:将引用的函数代码编译到引用点处,这样可以减少栈帧的生成,减少参数传递以及跳转过程
  - 去虚拟化:对唯一的实现类进行内联
  - 冗余消除:在运行期间把一些不会执行的代码折叠掉
- C2的优化主要是在全局层面,逃逸分析是优化的基础。基于逃逸分析在C2上有如下几种优化:
  - 标量替换:用标量值代替聚合对象的属性值
  - 栈上分配:对于未逃逸的对象分配对象在栈而不是堆
  - 同步消除:清除同步操作,通常指 synchronized

## 九.String Table

- string声明为final的,不可被继承
- string:实现了 Serializable接口:表示字符串是支持序列化的。
- 实现了 Comparable接口:表示 string可以比较大小
  string在jdk8及以前内部定义了 final char[] value用于存储字
- 符串数据。jdk9时改为byte[]

### String的基本特性

- 字符串常量池中是不会存储相同内容的字将串的。
  string的 string Pool是一个固定大小的 Hashtable,默认值大小长度是1009。如果放进 string Pool的 string非常多,就会造成Hash冲突严重,从而导致链表会很长,而链表长了后直接会造成的影响就是当调用string. intern时性能会大幅下降。

- 使用-XX: StringTableSize可设置 StringTable的长度

- 在jdk6中 Stringtable是固定的,就是1009的长度,所以如果常量池中的字符串过多就会导致效率下降很快。 StringTablesize设置没有要求

- 在jdk7中, Stringtable的长度默认值是60013,1009是可设置的最小值

- ```java
  C:\Users\YQ>jps
  10192 StringTableSizeTest
  14832 Launcher
  2716 Jps
  5068
  
  C:\Users\YQ>jinfo -flag StringTableSize 10192
  -XX:StringTableSize=60013
  ```

### 2. String的内存分配

在Java语言中有8种基本数据类型和一种比较特殊的类型 string。这些类型为了使它们在运行过程中速度更快、更节省内存,都提供了一种常量池的概念。
常量池就类似一个Java系统级别提供的缓存。8种基本数据类型的常量池都是系统协调的, string类型的常量池比较特殊。它的主要使用方法有两种。

- 直接使用双引号声明出来的 string对象会直接存储在常量池中。
  - 比如:String info="atguigu.com";
- 如果不是用双引号声明的 string对象,可以使用 string提供的
  intern()方法。这个后面重点谈

### 3. String的基本操作

Java语言规范里要求完全相同的字符串字面量,应该包含同样的 Unicode字符序列(包含同一份码点序列的常量),并且必须是指向同一个 string类实例。

![image-20220214143449384](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220214143449384.png)

### 4.字符串的拼接

1. 常量与常量的拼接结果在常量池,原理是编译期优化
2. 常量池中不会存在相同内容的常量
3. 只要其中有一个是变量,结果就在堆中。变量拼接的原理是StringBuilder
4. 如果拼接的结果调用 intern()方法,则主动将常量池中还没有的字符串对象放入池中,并返回此对象地址。

### 5. intern()的使用

- 如果不是用双引号声明的 string对象,可以使用 string提供的 intern方法: intern方法会从字符串常量池中査询当前字符串是否存在,若不存在就会将当前字符串放入常量池中。
  ·比如: String myInfo= new string("I love atguigu"). intern()
- 也就是说,如果在任意字符串上调用 string. intern方法,那么其返回结果所指向的那个类实例,必须和直接以常量形式出现的字符串实例完全相同。因此,下列表达式的值必定是true:
  ("a"+"b"+"c").intern() == "abc"
- 通俗点讲, Interned string就是确保字符串在内存里只有一份拷贝,这样可以节约内存空间,加快字符串操作任务的执行速度。注意,这个值会被存放在字符串内部池( String Intern Pool)。

总结 string的 intern()的使用
jdk1.6中,将这个字符串对象尝试放入串池

- 如果串池中有,则并不会放入。返回已有的串池中的对象的地址
- 如果没有,会把**此对象复制一份**,放入串池,并返回串池中的对
  象地址

Jdk1.7起,将这个字符串对象尝试放入串池

- 如果串池中有,则并不会放入。返回已有的串池中的对象的地址
- 如果没有,则会把**对象的引用地址复制一份**,放入串池,并返回
  串池中的引用地址

## 十.垃圾回收

### 1.垃圾回收概述

关于垃圾收集有三个经典问题:

- 哪些内存需要回收?
- 什么时候回收?
- 如何回收?

垃圾收集机制是Java的招牌能力,极大地提高了开发效率。如今,垃圾
收集几乎成为现代语言的标配,即使经过如此长时间的发展,Java的垃
圾收集机制仍然在不断的演进中,不同大小的设备、不同特征的应用场景,对垃圾收集提出了新的挑战,这当然也是面试的热点。

#### 1.什么是垃圾?

- 什么是垃圾( Garbage)呢?
  - 垃圾是指在运行程序中没有任何指针指向的对象,这个对象就是需要被回收的垃圾。
  -  An object is considered garbage when it can no
    longer be reached from any pointer in the running
    program
- 如果不及时对内存中的垃圾进行清理,那么,这些垃圾对象所占的内存空间会一直保留到应用程序结束,被保留的空间无法被其他对象使用。甚至可能导致内存溢出

#### 2.为什么需要GC

- 对于高级语言来说,一个基本认知是如果不进行垃圾回收,内存迟早都会被消耗完,因为不断地分配内存空间而不进行回收,就好像不停地生产生活垃圾而从来不打扫一样
- 除了释放没用的对象,垃圾回收也同以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端,以便JVM将整理出的内存分配给新的对象。
- 随着应用程序所应付的业务越来越庞大、复杂,用户越来越多,没有GC就不能保证应用程序的正常进行。而经常造成STW的GC又跟不上实际的需求,所以才会不断地尝试对GC进行优化

#### 3.Java垃圾回收机制

- 自动内存管理,无需开发人员手动参与内存的分配与回收,这样降低内存泄漏和内存溢出的风险
- 没有垃圾回收器,java也会和cpp一样,各种悬垂指针,野指针,泄露问题让你头疼不已。
- 自动内存管理机制,将程序员从繁重的内存管理中释放出来,可以更专心地专注于业务开发

![image-20220215130901114](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220215130901114.png)

垃圾回收器可以对年轻代回收,也可以对老年代回收,甚至是全堆和方
法区的回收。其中,Java堆是垃圾收集器的工作重点
从次数上讲:

>频繁收集 Young区
>较少收集Old区
>基本不动Pexm区(或元空间)

### 2.垃圾回收的算法

#### 1.垃圾标记阶段的算法之引用计数算法

垃圾标记阶段:对象存活判断

- 在堆里存放着几乎所有的Java对象实例,在GC执行垃圾回收之前,首先需要区分出内存中哪些是存活对象,哪些是已经死亡的对象。只有被标记为己经死亡的对象,GC才会在执行垃圾回收时,释放掉其所占用的内存空间,因此这个过程我们可以称为垃圾标记阶段。
- 那么在JVM中究竟是如何标记一个死亡对象呢?简单来说,当一个对象已经不再被任何的存活对象继续引用时,就可以宣判为已经死亡
- 判断对象存活一般有两种方式:**引用计数算法**和**可达性分析算法。**

引用计数算法( Reference Counting)比较简单,对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。

- 对于一个对象A,只要有任何一个对象引用了A,则A的引用计数器就加1;当引用失效时,引用计数器就减1。只要对象A的引用计数器的值为0,即表示对象A不可能再被使用,可进行回收。
- 优点:
  - 实现简单,垃圾对象便于辨识;判定效率高,回收没有延迟性。
- 缺点:
  - 它需要单独的字段存储计数器,这样的做法增加了存储空间的开销
  - 每次赋值都需要更新计数器,伴随着加法和减法操作,这增加了时间开销。
  - 引用计数器有一个严重的问题,即无法处理循环引用的情况。这是一条致命缺陷导致在Java的垃圾回收器中没有使用这类算法。

##### 小结

引用计数算法,是很多语言的资源回收选择,例如因人工智能而更加火热的 Python,它更是同时支持引用计数和垃圾收集机制
具体哪种最优是要看场景的,业界有大规模实践中仅保留引用计数机制,以提高吞吐量的尝试。
Java并没有选择引用计数,是因为其存在一个基本的难题,也就是很难处理循环引用关系。
Python如何解决循环引用?

- 手动解除:很好理解,就是在合适的时机,解除引用关系。
- 使用弱引用 weakref, weakref是 Python提供的标准库,旨在解
  决循环引用。

#### 2.垃圾标记阶段的算法之可达性分析算法(或根搜索算法、追踪性垃圾收集)

- 相对于引用计数算法而言,可达性分析算法不仅同样具备实现简单和执行高效等特点,更重要的是该算法可以有效地解决在引用计数算法中循环引用的问题,防止内存泄漏的发生。
- 相较于引用计数算法,这里的可达性分析就是Java、C#选择的。这种类型的垃圾收集通常也叫作追踪性垃圾收集( Tracing GarbageCollection)

所谓" GC Roots"根集合就是一组必须活跃的引用

- 基本思路
  - 可达性分析算法是以根对象集合( GC Roots)为起始点,按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。
  - 使用可达性分析算法后,内存中的存活对象都会被根对象集合直接或间接连接着,搜索所走过的路径称为**引用链**( Reference chain)
  - 如果目标对象没有任何引用链相连,则是不可达的,就意味着该对象己经死亡,可以标记为垃圾对象
  - 在可达性分析算法中,只有能够被根对象集合直接或者间接连接的对象才是存活对象
- ![image-20220215133246924](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220215133246924.png)

##### 在Java语言中, GC Roots包括以几类元素

- 虚拟机栈中引用的对象
  - 比如:各个线程被调用的方法中使用到的参数、局部变量等。
- 本地方法栈内JNI(通常说的本地方法)引用的对象
- 方法区中类静态属性引用的对象
  - 比如:Java类的引用类型静态变量
- 方法区中常量引用的对象
  - 比如:字符串常量池( String Table)里的引用
- 所有被同步锁 synchronized持有的对象
- Java虚拟机内部的引用。
  - 基本数据类型对应的Class对象,一些常驻的异常对象(如:
    NullPointerException、 OutofMemoryError),系统类加载器。
- 反映java虚拟机内部情况的 JMXBean、JⅥM中注册的回调、本地代码缓存等。

![image-20220215133600338](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220215133600338.png)

- 除了这些固定的 GC Roots集合以外,根据用户所选用的垃圾收集器以及当前回收的内存区域不同,还可以有其他对象“临时性”地加入,共同构成完整 GC Roots集合。比如:分代收集和局部回收( PartialGC)
  - 如果只针对Java堆中的某一块区域进行垃圾回收(比如:典型的只针对新生代),必须考虑到内存区域是虚拟机自己的实现细节,更不是孤立封闭的,这个区域的对象完全有可能被其他区域的对象所引用,这时候就需要一并将关联的区域对象也加入 GC Roots集合中去考虑,才能保证可达性分析的准确性
- 小技巧
  - 由于Root采用栈方式存放变量和指针,所以如果一个指针,它保存了堆内存里面的对象,但是自己又不存放在堆内存里面,那它就是一个Root

如果要使用可达性分析算法来判断内存是否可回收,那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证
这点也是导致GC进行时必须 "stop The World"的一个重要原因。
即使是号称(几乎)不会发生停顿的CMS收集器中,**枚举根节点时**
**也是必须要停顿的**

#### 3.对象的finalization机制

- Java语言提供了对象终止( finallization)机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。
- 当垃圾回收器发现没有引用指向一个对象,即:垃圾回收此对象之前,总会先调用这个对象的finalize()方法。
- finalize()方法允许在子类中被重写,用于在对象被回收时进行资源释放通常在这个方法中进行一些资源释放和清理的工作,比如关闭文件、套接字和数据库连接等。
- 永远不要主动调用某个对象的finalize()方法,应该交给垃圾回收机制调用。理由包括下面三点
  - 在finalize()时可能会导致对象复活。
  - finalize()方法的执行时间是没有保障的,它完全由GC线程决定,极端情况下,若不发生GC,则finalize()方法将没有执行机会
  - 一个糟糕的finalize()会严重影响GC的性能。
- 从功能上来说, finalize()方法与C++中的析构函数比较相似,但是Java采用的是基于垃圾回收器的自动内存管理机制,所以finalize()方法在本质上不同于C++中的析构函数。
- 由于finalize()方法的存在,**虚拟机中的对象一般处于三种可能的状态。**

- 如果从所有的根节点都无法访问到某个对象,说明对象己经不再使用了。一般来说,此对象需要被回收。但事实上,也并非是“非死不可”的,这时候它们暂时处于“缓刑”阶段。一个无法触及的对象有可能在某一个条件下“复活”自己,如果这样,那么对它的回收就是不合理的,为此,定义虚拟机中的对象可能的三种状态。如下:
  - 可触及的:从根节点开始,可以到达这个对象
  - 可复活的:对象的所有引用都被释放,但是对象有可能在finalize()中复活。
  - 不可触及的:对象的finalize()被调用,并且没有复活,那么就会进入不可触及状态。不可触及的对象不可能被复活,因为finalize()只会被调用一次。
- 以上3种状态中,是由于finalize()方法的存在,进行的区分。只有在对象不可触及时才可以被回收。

##### 具体过程

- 判定一个对象objA是否可回收,至少要经历两次标记过程:
  1. 如果对象objA到 GC Roots没有引用链,则进行第一次标记
  2. 进行筛选,判断此对象是否有必要执行finalize()方法
     1. 如果对象objA没有重写finalize()方法,或者finalize()方法已经被虚拟机调用过,则虚拟机视为“没有必要执行”,objA被判定为不可触及的。
     2. 如果对象objA重写了finalize()方法,且还未执行过,那么objA会被插入到F-queue队列中,由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize()方法执行。
     3. finalize()方法是对象逃脱死亡的最后机会,稍后GC会对F- Queue队列中的对象进行第二次标记。如果objA在finalize()方法中与引用链上的任何一个对象建立了联系,那么在第二次标记时,objA会被移出“即将回收”集合。之后,对象会再次出现没有引
        用存在的情况。在这个情况下,finalize方法不会被再次调用,对象会直接变成不可触及的状态,也就是说,一个对象的finalize方法只会被调用一次。

#### 4.MAT与 PRofiler的GC Roots溯源

MAT是 Memory Analyzer的简称,它是一款功能强大的Java堆内存分析器
用于査找内存泄漏以及査看内存消耗情况MAT是基于 Eclipse开发的,是一款免费的性能分析工具

[](https://www.eclipse.org/mat/)

#### 5.清除阶段

当成功区分出内存中存活对象和死亡对象后,GC接下来的任务就是执行垃圾回收,释放掉无用对象所占用的内存空间,以便有足够的可用内存空间为新对象分配内存
目前在JVM中比较常见的三种垃圾收集算法是，标记一清除算法(Mark swep)、复制算法( Copying)、标记-压缩算法(Mark Compact)

##### 1.标记清除算法

执行过程:
当堆中的有效内存空间( available memory)被耗尽的时候,就会停止整个程序(也被称为 stop the world),然后进行两项工作,第一项则是标记,第二项则是清除。

- 标记:Collector从引用根节点开始遍历,标记所有被引用的对象。一般是在对象的 Header中记录为可达对象。
- 清除: Collector对堆内存从头到尾进行线性的遍历,如果发现某个对象在其 Header中没有标记为可达对象,则将其回收

![image-20220215145710701](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220215145710701.png)

缺点

- 效率不算高
  - 在进行GC的时候,需要停止整个应用程序,导致用户体验差
  - 这种方式清理出来的空闲内存是不连续的,产生内存碎片。需要维护一个空闲列表
- 注意:何为清除?
  - 这里所谓的清除并不是真的置空,而是把需要淸除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时,判断垃圾的位置空间是否够,如果够,就存放。

##### 2.复制算法

核心思想
将活着的内存空间分为两块,每次只使用其中一块,在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中,之后清除正在使用的内存块中的所有对象,交换两个内存的角色,最后完成垃圾回收。

![image-20220215150243773](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220215150243773.png)

优点

- 没有标记和清除过程,实现简单,运行高效
- 复制过去以后保证空间的连续性,不会出现“碎片”问题

缺点:

- 此算法的缺点也是很明显的,就是需要两倍的内存空间。
- 对于G1这种分拆成为大量 region的GC,复制而不是移动,意味着GC需要维护 region之间对象引用关系,不管是内存占用或者时间开销也不小

特别的:

- 如果系统中的存活对象很多,复制算法需要复制的存活对象数量并不会太大或者说非常低才行。

应用场景
在新生代,对常规应用的垃圾回收,一次通常可以回收70%-99%的内存空间。回收性价比很高。所以现在的商业虚拟杋都是用这种收集算法回收新生代。

##### 3.标记压缩(或标记整理、Mark- Compact)算法

复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代常发生,但是在老年代,更常见的情况是大部分对象都是存活对象。如果依然使用复制算法,由于存活对象较多,复制的成本也将很高。因此,基于老年代垃圾回收的特性,需要使用其他的算法。 

执行过程

- 第一阶段和标记清除算法一样,从根节点开始标记所有被引用
  对象
- 第二阶段将所有的存活对象压缩到内存的一端,按顺序排放。
  之后,清理边界外所有的空间。
- ![image-20220215151235403](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220215151235403.png)

标记-压缩算法的最终效果等同于标记-清除算法执行完成后,再进行一次内存碎片整理,因此,也可以把它称为标记-清除-压缩(Mark- Sweep
Compact)算法。
二者的本质差异在于标记-清除算法是一种非移动式的回收算法,标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策
可以看到,标记的存活对象将会被整理,按照内存地址依次排列,而未被
标记的内存会被清理掉。如此一来,当我们需要给新对象分配内存时,
JVM只需要持有一个内存的起始地址即可,这比维护一个空闲列表显然少了许多开销

优点

- 消除了标记-清除算法当中,内存区域分散的缺点,我们需要给新对象分配内存时,JVM只需要持有一个内存的起始地址即可
- 消除了复制算法当中,内存减半的高额代价。

缺点:

- 从效率上来说,标记-整理算法要低于复制算法
- 移动对象的同时,如果对象被其他对象引用,则还需要调整引用的地址
- 移动过程中,需要全程暂停用户应用程序。即:STW

##### 分代收集算法

- 前面所有这些算法中,并没有一种算法可以完全替代其他算法,它们都具有自己独特的优势和特点。分代收集算法应运而生
- 分代收集算法,是基于这样一个事实:不同的对象的生命周期是不一样的。因此,不同生命周期的对象可以采取不同的收集方式,以便提高回收效率。一般是把Java堆分为新生代和老年代,这样就可以根据各个年代的特点使用不同的回收算法,以提高垃圾回收的效率
- 在Java程序运行的过程中,会产生大量的对象,其中有些对象是与业务信息相关,比如Http请求中的 Session对象、线程、 Socket连接,这类对象跟业务直接挂钩,因此生命周期比较长。
- 但是还有一些对象,主要是程序运行过程中生成的临时变量,这些对象生命周期会比较短,比如: string对象,由于其不变类的特性,系统会产生大量的这些对象,有些对象甚至只用一次即可回收。
- 目前几乎所有的GC都是采用分代收集( Generational Collecting)算法执行垃圾回收的。
- 在 Hotspot中,基于分代的概念,GG所使用的内存回收算法必须结合年轻代和老年代各自的特点
  - 年轻代( Young Gen)
    年轻代特点:区域相对老年代较小,对象生命周期短、存活率低,回收频繁。这种情况复制算法的回收整理,速度是最快的。复制算法的效率只和当前存活对象大小有关,因此很适用于年轻代的回收。而复制算法内存利用率不高的问题,通过 hotspot中的两个 survIvor的设计得到缓解。
  - 老年代( Tenured gen)
    老年代特点:区域较大,对象生命周期长、存活率高,回收不及年轻代频繁。这种情况存在大量存活率高的对象,复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。
    - Maxk(标记)阶段的开销与存活对象的数量成正比。
    - Sweep(清除)阶段的开销与所管理区域的大小成正相关
    - Compact(压缩)阶段的开销与存活对象的数据成正比

以 Hotspot中的CMS回收器为例,CMS是基于Mark-Swep实现的,对于对象的回收效率很高。而对于碎片问题,CMS采用基于Mark- Compact算法的 Serial Old回收器作为补偿措施:当内存回收不佳(碎片导致的 (Concurrent mode Failure时),将采用 Serial Old执行Full GC以达到对老年代内存的整理。

#### 4.增量收集算法、分区算法

##### 增量收集算法

上述现有的算法,在垃圾回收过程中,应用软件将处于一种 Stop the World的状态。在 Stop the World状态下,应用程序所有的线程都会挂起,暂停一切正常的工作,等待垃圾回收的完成。如果垃圾回收时间过长,应用程序会被挂起很久,将严重影响用户体验或者系统的稳定性。为了解决这个问题,即对实垃圾收集算法的研究直接导致了增量收集( Incremental collecting)算法的诞生。

###### 基本思想

如果一次性将所有的垃圾进行处理,需要造成系统长时间的停顿,那么就可以让垃圾收集线程和应用程序线程交替执行。每次,垃圾收集线程只收集一小片区域的内存空间,接着切换到应用程序线程。依次反复,直到垃圾收集完成
总的来说,增量收集算法的基础仍是传统的标记-淸除和复制算法。増量收集算法通过对线程间冲突的妥善处理,允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。

###### 缺点:

使用这种方式,由于在垃圾回收过程中,间断性地还执行了应用程序代码,所以能减少系统的停顿时间。但是,因为线程切换和上下文转换的消耗,会使得垃圾回收的总体成本上升,造成系统吞吐量的下降。

##### 分区算法

般来说,在相同条件下,堆空间越大,一次GC时所需要的时间就越长,有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间,将一块大的内存区域分割成多个小块,根据目标的停顿时间,每次合理地回收若干个小区间,而不是整个堆空间,从而减少一次GC所产生的停顿。
分代算法将按照对象的生命周期长短划分成两个部分,分区算法将整个堆空间划分成连续的不同小区间
每一个小区间都独立使用,独立回收。这种算法的好处是可以控制一次回收多少个小区间。



![image-20220215153008896](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220215153008896.png)

### 3.垃圾回收相关概念

#### 1.System.gc()的理解

- 在默认情况下,通过 System.gc()或者 Runtime. getRuntime().gc()的调用,会显式触发Full GC,同时对老年代和新生代进行回收,尝试释放被丢弃对象占用的内存。
- 然而 System.gc()调用附带一个免责声明,无法保证对垃圾收集器的调用。
- JVM实现者可以通过 System.gc()调用来决定JVM的GC行为。而一般情况下,垃圾回收应该是自动进行的,无须手动触发,否则就太过于麻烦了。在些特殊情况下,如我们正在编写一个性能基准,我们可以在运行之间调用System.gc()。

```java
public class SystemGCTest01 {
    public static void main(String[] args) {
        new SystemGCTest01();
        System.gc();//提醒JVM的垃圾回收器执行gc,但是不确定是否马上执行gc
        System.runFinalization();//强制调用失去引用的对象的finalize()方法
    }

    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println("重写了finalize");
    }
}
```

#### 2.内存溢出与内存泄漏

##### 内存溢出

- 内存溢出相对于内存泄漏来说,尽管更容易被理解,但是同样的,内存溢出也是引发程序崩溃的罪魁祸首之一。
- 由于GC一直在发展,所有一般情况下,除非应用程序占用的内存增长速度非常快,造成垃圾回收已经跟不上内存消耗的速度,否则不太容易出现OOM的情况。
- 大多数情况下,GC会进行各种年龄段的垃圾回收,实在不行了就放大招,来一次独占式的 Full GC操作,这时候会回收大量的内存,供应用程序继续使用。
- javadoc中对 OutOfMemoryError的解释是,没有空闲内存,并且垃圾收集器也无法提供更多内存

- 首先说没有空闲内存的情况:说明]ava虚拟机的堆内存不够。原因有
  j
  - ava虚拟机的堆内存设置不够
    比如:可能存在内存泄漏问题;也很有可能就是堆的大小不合理,比如我们要处理比较可观的数据量,但是没有显式指定JVM堆大小或者指定数值偏小。我们可以通过参数-Xms
    -Xmx来调整。
  - 代码中创建了大量大对象,并且长时间不能被垃圾收集器收集(存在被引用)
  - 对于老版本的Oracle JDK,因为永久代的大小是有限的,并且JVM对永久代垃圾回收(如,常量池回收、卸载不再需要的类型)非常不积极,所以当我们不断添加新类型的时候,永久代出现 OutofmemoryError也非常多见,尤其是在运行时存在大量动态类型生成的场合;类似 intern字符串缓存占用太多空间,也会导致OOM问题。对应的异常信息,会标记出来和永久代相关:“java.lang. OutofmemoryError: PermGen space"。
- 随着元数据区的引入,方法区内存已经不再那么窘迫,所以相应的OOM有所改观,出现
  OOM,异常信息则变成了:“java.lang. OutofMemoryError: Metaspace"。直接内存不足,也会导致OOM。

- 这里面隐含着一层意思是,在抛出 OutOfMemoryError之前,通常垃圾收集器会被触发,尽其所能去清理出空间。
  - 例如:在引用机制分析中,涉及到JVM会去尝试回收软引用指向的对象等。
  - 在java.nio.BIts. reserveMemory()方法中,我们能清楚的看到, System.gc()会被调用,以清理空间。
- 当然,也不是在任何情况下垃圾收集器都会被触发的
  比如,我们去分配一个超大对象,类似一个超大数组超过堆的最大值,JVM可以判断出垃圾收集并不能解决这个问题,所以直接抛出 OutOfMemoryError。

##### 内存泄漏

- 也称作“存储渗漏”。严格来说,只有对象不会再被程序用到了,但是GC又不能回收他们的情况,才叫内存泄漏。
- 但实际情况很多时候一些不太好的实践(或疏忽)会导致对象的生命周期变得很长甚至导致OOM,也可以叫做宽泛意义上的“内存泄漏”。
- 尽管内存泄漏并不会立刻引起程序崩溃,但是一旦发生内存泄漏,程序中的可用内存就会被逐步蚕食,直至耗尽所有内存,最终出现 OutofMemory异常,导致程序崩溃。
- 注意,这里的存储空间并不是指物理内存,而是指虚拟内存大小,这个虚拟内存大小取决于磁盘交换区设定的大小。

![image-20220216113930305](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220216113930305.png)

举例:
1、单例模式
单例的生命周期和应用程序是一样长的,所以单例程序中,如果持有对
外部对象的引用的话,那么这个外部对象是不能被回收的,则会导致内
存泄漏的产生。
2、一些提供 close的资源未关闭导致内存泄漏
数据库连接( datasource. getConnection()),网络连接( socket)和
io连接必须手动 close,否则是不能被回收的。

#### 3. Stop The Word(STW)

- stop-the- World,简称STW,指的是GC事件发生过程中,会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停,没有任何响应,有点像卡死的感觉,这个停顿称为STW。
- 可达性分析算法中枚举根节点( GC Roots)会导致所有Java执行线程停顿
  - 分析工作必须在一个能确保一致性的快照中进行
  - 一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上
  - 如果出现分析过程中对象引用关系还在不断变化,则分析结果的准确性无法保证
- 被STW中断的应用程序线程会在完成GC之后恢复,频繁中断会让用户感觉像是网速不快造成电影卡带一样,所以我们需要减少STW的发生。

- STW事件和采用哪款GC抚关,所有的GC都有这个事件
- 哪怕是G1也不能完全避免Stop-the- world情况发生,只能说垃圾回收器越来越优秀,回收效率越来越高,尽可能地缩短了暂停时间。
- STW是JVM在后台自动发起和自动完成的。在用户不可见的情况下,把用户正常的工作线程全部停掉
- 开发中不要用 System.gc();会导致Stop-the-Wor1d的发生。

#### 4,垃圾回收的并行与并发

##### 并发

- 在操作系统中,是指一个时间段中有几个程序都处于已启动运行到运行完毕之间,且这几个程序都是在同一个处理器上运行。
- 并发不是真正意义上的“同时进行”,只是CPU把一个时间段划分成几个时间片段(时间区间),然后在这几个时间区间之间来回切换,由于CPU处理的速度非常快,只要时间间隔处理得当,即可让用户感觉是多个应用程序同时在进行

##### 并行

- 当系统有一个以上CPU时,当一个CPU执行一个进程时,另一个CPU可以执行另一个进程两个进程互不抢占CPU资源,可以同时进行,我们称之为并行(Parallel)。
- 其实决定并行的因素不是CPU的数量,而是CPU的核心数量,比如一个CPU多个核也可以并行。
- 适合科学计算,后台处理等弱交互场景

##### 二者对比

- 并发,指的是多个事情,在同一时间段内同时发生了
- 并行,指的是多个事情,在同一时间点上同时发生了
- 并发的多个任务之间是互相抢占资源的。
- 并行的多个任务之间是不互相抢占资源的。
- 只有在多CPU或者一个CPU多核的情况中,才会发生并行。否则,看似同时发生的事情,其实都是并发执行的

##### 垃圾回收的并发与并行

并发和并行,在谈论垃圾收集器的上下文语境中,它们可以解释如下

- 并行(Parallel):指多条垃圾收集线程并行工作,但此时用户线程仍处于等待状态
  - 如 ParNew、Parallel Scavenge、Parallel old;
- 串行( Serial)
  - 相较于并行的概念,单线程执行
  - 如果内存不够,则程序暂停,启动JVM垃圾回收器进行垃圾回收。回收完,再启动程序的线程。

并发和并行,在谈论垃圾收集器的上下文语境中,它们可以解释如下

- 并发( Concurrent):指用户线程与垃圾收集线程同时执行(但不一定是并行的,可能会交替执行),垃圾回收线程在执行时不会停顿用户程序的运行。
  - 用户程序在继续运行,而垃圾收集程序线程运行于另一个CPU上;
  - 如:CMS、G1

#### 5.安全点与安全区域

程序执行时并非在所有地方都能停顿下来开始GC,只有在特定的位置才能停顿下来开始GC,这些位置称为“安全点( Safe point)”。

Safe point的选择很重要,如果太少可能导致GC等待的时间太长,如果
太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂,通常会根据“是否具有让程序长时间执行的特征”为标准。比如:选择些执行时间较长的指令作为 Safe point,如方法调用、循环跳转和异常跳转等

如何在GC发生时,检查所有线程都跑到最近的安全点停顿下来呢?

- 抢先式中断:(目前没有虚拟机采用了)
  首先中断所有线程。如果还有线程不在安全点,就恢复线程,让线程跑到安全点。
- 主动式中断:
  设置一个中断标志,各个线程运行到 Safe point的时候主动轮询这个标志如果中断标志为真,则将自己进行中断挂起。

安全区域( Safe Region)

Safe point机制保证了程序执行时,在不太长的时间内就会遇到可进入GC的 Safe point。但是,程序“不执行”的时候呢?例如线程处于 Sleep状态或 Blocked状态,这时候线程无法响应JVM的中断请求,“走”到安全点去中断挂起,JVM也不太可能等待线程被唤醒。对于这种情况,就需要安全区域( Safe region)来解决。

安全区域是指在一段代码片段中,对象的引用关系不会发生变化,在这个区域中的任何位置开始GC都是安全的。我们也可以把 Safe Region看做是被扩展了的 Safe point。

实际执行时:

1. 当线程运行到 Safe Region的代码时,首先标识已经进入了 Safe Region,如果这段时间内发生GC,JVM会忽略标识为 Safe region状态的线程;
2. 当线程即将离开 Safe Region时,会检查JVM是否已经完成GC,如果完成了,则继续运行,否则线程必须等待直到收到可以安全离开 Safe Region的信号为止

#### 6.再谈引用:强引用

我们希望能描述这样一类对象:当内存空间还足够时,则能保留在内存中;如果内存空间在进行垃圾收集后还是很紧张,则可以抛弃这些对象

【既偏门又非常高频的面试题】强引用、软引用、弱引用、虚引用有什么区别?具体使用场景是什么?

在JDK1.2版之后,Java对引用的概念进行了扩充,将引用分为强引用( Strong Reference)、软引用( Soft Reference)、弱引用( Weak Reference)和虚引用( Phantom Reference)4种,这**4种引用强度依次逐渐减弱**

除强引用外,其他3种引用均可以在java.lang,ref包中找到它们的身影。如下图,显示了这3种引用类型对应的类,开发人员可以在应用程序中直接使用它们。

![image-20220216120038843](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220216120038843.png)



Reference子类中只有终结器引用是包内可见的,其他3种引用类型均为 public,可以在应用程序中直接使用

- 强引用( Strong Reference):最传统的“引用”的定义,是指在程序代码之中普遍存在的引用赋值,即类似“ object obj= new Object()”这种引用关系。无论任何情况下**只要强引用关系还存在,垃圾收集器就永远不会回收掉被引用的对象**。
- 软引用( Soft Reference):在系统将要发生内存溢出之前,将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存,才会抛出内存溢出异常
- 弱引用( Weak Reference):被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时,无论内存空间是否足够,都会回收掉被弱引用关联的对象
- 虚引用( Phantom Reference):一个对象是否有虚引用的存在,完全不会对其生存时间构成影响,也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的**唯一目的就是能在这个对象被收集器回收时收到一个系统通知。**

强引用( Strong Reference)—不回收

- 在Java程序中,最常见的引用类型是强引用(普通系统99%以上都是强引用),也就是我们最常见的普通对象引用,也是默认的引用类型。
- 当在]ava语言中使用new操作符创建一个新的对象,并将其赋值给一个变量的时候,这个变量就成为指向该对象的一个强引用。
- 强引用的对象是可触及的,垃圾收集器就永远不会回收掉被引用的对象
- 对于一个普通的对象,如果没有其他的引用关系,只要超过了引用的作用域或者显式地将相应(强)引用赋值为null,就是可以当做垃圾被收集了,当然具体回收时机还是要看垃圾收集策略。
- 相对的,软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的,在一定条件下,都是可以被回收的。所以,强引用是造成Java内存泄漏的主要原因之一

- 强引用可以直接访问目标对象。
- 强引用所指向的对象在任何时候都不会被系统回收,虚拟机宁愿抛出OOM异常,地不会回收强引用所指向对象。
- 强引用可能导致内存泄漏。

#### 7.软引用( Soft reference)一内存不足即回收

- 软引用是用来描述一些还有用,但非必需的对象。只被软引用关联着的对象在系统将要发生内存溢出异常前,会把这些对象列进回收范围之中进行第二次回收,如果这次回收还没有足够的内存,才会抛出内存溢出异常。
- 软引用通常用来实现内存敏感的缓存。比如:高速缓存就有用到软引用。如果还有空闲内存,就可以暂时保留缓存,当内存不足时清理掉,这样就保证了使用缓存的同时,不会耗尽内存。
- 垃圾回收器在某个时刻决定回收软可达的对象的时候,会清理软引用,并可选地把引用存放到一个引用队列( Reference queue)。
- 类似弱引用,只不过Java虚拟机会尽量让软引用的存活时间长一些,迫不得已才清理。

```java
Object obj= new Object();//声明强引用
SoftReference<object> sf = new SoftReference<object>(obj)
obj=nu11;//销毁强引用
```

#### 8,弱引用( Weak Reference)一发现即回收

- 弱引用也是用来描述那些非必需对象,只被弱引用关联的对象只能生存到下一次垃圾收集发生为止。在系统GC时,只要发现弱引用,不管系统堆空间使用是否充足,都会回收掉只被弱引用关联的对象。
- 但是,由于垃圾回收器的线程通常优先级很低,因此,并不一定能很快地发现持有弱引用的对象。在这种情况下,弱引用对象可以存在较长的时间。
- 弱引用和软引用一样,在构造弱引用时,也可以指定一个引用队列,当弱引用对象被回收时,就会加入指定的引用队列,通过这个队列可以跟踪对象的回收情况。
- 软引用、弱引用都非常适合来保存那些可有可无的缓存数据。如果这么做,当系统内存不足时,这些缓存数据会被回收,不会导致内存溢出。而当内存资源充足时,这些缓存数据又可以存在相当长的时间,从而起到加速系统的作用。

#### 9.虚引用( Phantom Reference)一对象回收跟踪

- 也称为“幽灵引用”或者“幻影引用”,是所有引用类型中最弱的一个,
  一个对象是否有虚引用的存在,完全不会决定对象的生命周期。
- 如果一个对象仅持有虚引用,那么它和没有引用几乎是一样的,随时都可能被垃圾回收器回收
- 它不能单独使用,也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get()方法取得对象时,总是null
- 为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如:能在这个对象被收集器回收时收到一个系统通知
- 虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时,如果发现它还有虚引用,就会在回收对象后,将这个虚引用加入引用队列,以通知应用程序对象的回收情况。
- 由于虚引用可以跟踪对象的回收时间,因此,也可以将一些资源释放操作放置在虚引用中执行和记录。

#### 10.再谈引用:终结器引用(FInal Reference)

它用以实现对象的finalize()方法,也可以称为终结器引用。
无需手动编码,其内部配合引用队列使用。
在GC时,终结器引用入队。由 Finalize线程通过终结器引用找到被引用对象并调用它的finalize()方法,第二次GC时才能回收被引用对象。

### 十一、垃圾回收器

#### 1.GC分类与性能指标

按线程数分,可以分为串行垃圾回收器和并行垃圾回收器。

- 串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作,此时工作线程被暂停,直至垃圾收集工作结束。
  - 在诸如单CPU处理器或者较小的应用内存等硬件平台不是特别优越的场合,串行回收器的性能表现可以超过并行回收器和并发回收器。所以,串行回收默认被应用在客户端的 Client模式下的JVM中
  - 在并发能力比较强的CPU上,并行回收器产生的停顿时间要短于串行回收器。
- 和串行回收相反,并行收集可以运用多个CPU同时执行垃圾回收,因此提升了应用的吞吐量,不过并行回收仍然与串行回收一样,采用独占式,使用了“stop-the- world”机制。

按照工作模式分,可以分为并发式垃圾回收器和独占式垃圾回收器。

- 并发式垃圾回收器与应用程序线程交替工作,以尽可能减少应用程序的停顿时间
- 独占式垃圾回收器( Stop the world)一旦运行,就停止应用程序中的所有用户线程,直到垃圾回收过程完全结束

按碎片处理方式分,可分为压缩式垃圾回收器和非压缩式垃圾回收器

- 压缩式垃圾回收器会在回收完成后,对存活对象进行压缩整理,消除回收后的碎片
- 非压缩式的垃圾回收器不进行这步操作

按工作的内存区间分,又可分为年轻代垃圾回收器和老年代垃圾回收器。

##### 评估GC的性能指标

- **吞吐量**:运行用户代码的时间占总运行时间的比例
  - (总运行时间:程序的运行时间+内存回收的时间)
- 垃圾收集开销:吞吐量的补数,垃圾收集所用时间与总运行时间的比例
- **暂停时间**:执行垃圾收集时,程序的工作线程被暂停的时间。
- 收集频率:相对于应用程序的执行,收集操作发生的频率。
- **内存占用**:Java堆区所占的内存大小
- 快速:一个对象从诞生到被回收所经历的时间。

- 这三者共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项
- 这三项里,暂停时间的重要性日益凸显。因为随着硬件发展,内存占用多些越来越能容忍,硬件性能的提升也有助于降低收集器运行时对应用程序的影响,即提高了吞吐量。而内存的扩大,对延迟反而带来负面效果
- 简单来说,主要抓住两点
  - 吞吐量
  - 暂停时间

##### 评估GC的性能指标:吞吐量 (throughput))

- 吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值,即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)。
  - 比如:虚拟机总共运行了188分钟,其中垃圾收集花掉1分钟,那吞吐量就是99%。
- 这种情况下,应用程序能容忍较高的暂停时间,因此,髙吞吐量的应用程序有更长的时间基准,快速响应是不必考虑的。
- 吞吐量优先,意味着在单位时间内,STW的时间最短:θ.2+0.2=0.4

![image-20220216131249984](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220216131249984.png)

##### 评估GC的性能指播标:暂停时间( pause time)

- “暂停时间”是指一个时间段内应用程序线程暂停,让GC线程执行的状态
  - 例如,GC期间188毫秒的暂停时间意味着在这18θ毫秒期间内没有应用程序线程是活动的。
- 暂停时间优先,意味着尽可能让单次STW的时间最短:θ.1+.1+0.1+
  0.1+0.1=0.5

![image-20220216131356025](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220216131356025.png)

在设计(或使用)GC算法时,我们必须确定我们的目标:一个GC算法只
可能针对两个目标之一(即只专注于较大吞吐量或最小暂停时间),或
尝试找到一个二者的折衷。
**现在标准:在最大吞吐量优先的情况下,降低停顿时间。**

#### 2.不同的坟圾回收器概述

##### 7款经典收集翳与垃圾分代之间的关系

![image-20220216132712862](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220216132712862.png)

新生代收集器: Serial、 ParNew、Parallel Scavenge;
老年代收集器: Serial old、Parallel old、CMS
整堆收集器:G1

##### 垃圾收集器的组合关系

![image-20220216132815063](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220216132815063.png)

- 为什么要有很多收集器,一个不够吗?因为Java的使用场景很多,移动端,服务器等。所以就需要针对不同的场景,提供不同的垃圾收集器,提高垃圾收集的性能。
- 虽然我们会对各个收集器进行比较,但并非为了挑选一个最好的收集器出来。没有一种放之四海皆准、任何场景下都适用的完美收集器存在,更加没有万能的收集器。所以我们选择的只是对具体应用最合适的收集器

如何查看默认的垃圾收集噩

- -XX:+PrintCommandLineFlags:查看命令行相关参数(包含使用的垃圾收集器)
- 使用命令行指令: jinfo -flag 相关垃圾回收器参数 进程ID

```
C:\Users\YQ>jps
18128 Launcher
5476 GCUseTest
12888 Jps
2188

C:\Users\YQ>jinfo -flag useParallelGC 5476
no such flag 'useParallelGC'

C:\Users\YQ>jinfo -flag UseParallelGC 5476
-XX:+UseParallelGC

C:\Users\YQ>jinfo -flag UseParallelOldGC 5476
-XX:+UseParallelOldGC

C:\Users\YQ>

C:\Users\YQ>jinfo -flag UseG1GC 5476
-XX:-UseG1GC
```

##### 3. Serial回收器串行回收

- Serial收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3之前回收新生代唯一的选择。
- Serial收集器作为 Hotspot中 Client模式下的默认新生代垃圾收集器。
- Serial收集器采用复制算法、串行回收和〃stop-the-World"机制的方式执行内存回收。
- 除了年轻代之外, Serial收集器还提供用于执行老年代垃圾收集的Serial Old收集器。 Serial Old收集器同样也采用了串行回收
  和〃 Stop the World"机制,只不过内存回收算法使用的是标记-压缩-算法
  - Serial Old是运行在 Client模式下默认的老年代的垃圾回收器
  - Serial Old在 Server模式下主要有两个用途:
    - ①与新生代的Parallel Scavenge配合使用
    - ②作为老年代CMS收集器的后备垃圾收集方案

![image-20220216134405029](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220216134405029.png)

这个收集器是一个单线程的收集器,但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作,更重要的是在它进行垃圾收集时,必须暂停其他所有的工作线程,直到它收集结束( Stop The World)。

- 优势:简单高效(与其他收集器的单线程比),对于限定单个CPU的
  环境来说, Serial收集器由于没有线程交互的开销,专心做垃圾收集自然可以获得最高的单线程收集效率。
  - 运行在Client模式下的虚拟机是个不错的选择。
- 在用户的桌面应用场景中,可用内存一般不大(几十MB至一两百MB)可以在较短时间内完成垃圾收集(几十ms至一百多ms),只要不频繁发生,使用串行回收器是可以接受的。
- 在 Hotspot虚拟机中,使用-XX:+UseSerialGC参数可以指定年轻代和老年代都使用串行收集器。等价于新生代用 Serial GC,且老年代用 Serial Old GC

##### 4-.ParNew回收器:并行回收

- 如果说 Serial GC是年轻代中的单线程垃圾收集器,那么 ParNew收集器则是 Serial收集器的多线程版本。
  - Par是Parallel的缩写,New:只能处理的是新生代
- ParNew收集器除了采用并行回收的方式执行内存回收外,两款垃圾收集器之间几乎没有任何区别。 ParNew收集器在年轻代中同样也是采用复制算法、"stop-the- World"机制。
- ParDew是很多JVM运行在 Server模式下新生代的默认垃圾收集器

![image-20220216135139615](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220216135139615.png)

- 对于新生代,回收次数频繁,使用并行方式高效。
- 对于老年代,回收次数少,使用串行方式节省资源。(CPU并行需要切换线程,串行可以省去切换线程的资源

- 由于 ParNew收集器是基于并行回收,那么是否可以断定ParNeW收集器的回收效率在任何场景下都会比 Serial收集器更高效?
  - ParNew收集器运行在多CPU的环境下,由于可以充分利用多CPU、多核心等物理硬件资源优势,可以更快速地完成垃圾收集,提升程序的吞吐量。
  - 但是在单个CPU的环境下, ParNew收集器不比 Serial收集器更高效。虽然 Serial收集器是基于串行回收,但是由于CPU不需要频繁地做任务切换,因此可以有效避免多线程交互过程中产生的一些额外开销
- 因为除 Serial外,目前只有 ParNew GC能与CMS收集器配合工作

- 在程序中,开发人员可以通过选项"-XX:+UseParNewGC"手动指定使用ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器,不影响老年代。
- -XX:ParallelGCThreads限制线程数量,默认开启和CPU数据相同的线程数

##### 5-Parallel回收器吞吐量优先(JDK8默认)

- Hotspot的年轻代中除了拥有 ParNew收集器是基于并行回收的以外,Parallel Scavenge收集器同样也釆用了复制算法、并行回收和"stop the world"机制。

- 那么Parallel收集器的出现是否多此一举?和 ParNew收集器不同,Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量( Throughput),它也被称为吞吐量优先的垃圾收集器
- 自适应调节策略也是Parallel Scavenge与 ParNew一个重要区别

- 高吞吐量则可以高效率地利用CPU时间,尽快完成程序的运算任务,主要适合在后台运算而不需要太多交互的任务。因此,常见在服务器环境中使用。例如,那些执行批量处理、订单处理、工资支付、科学计算的应用程序
- Parallel收集器在JDK1.6时提供了用于执行老年代垃圾收集的
  Parallel old收集器,用来代替老年代的 Serial old收集器
- Parallel old收集器采用了标记-压缩算法,但同样也是基于并行回收和Stop-the-World"机制。

![image-20220216140201910](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220216140201910.png)

- 在程序吞吐量优先的应用场景中,Parallel收集器和parallel Old
  收集器的组合,在 Server模式下的内回收性能很不错。
- 在Java8中,默认是此垃圾收集器

- 参数配置:
  - -XX:+UseParallelGC手动指定年轻代使用Parallel并行收集器执行内存回收任务。
  - -XX:+UseparallelOldGC手动指定老年代都是使用并行回收收集器
    - 分别适用于新生代和老年代。默认jdk8是开启的。
    - 上面两个参数,默认开启一个,另一个也会被开启。(互相激活)
  - -XX:+ParallelGCThreads设置年轻代并行收集器的线程数。
    - 一般地,最好与CPU数量相等,以避免过多的线程数影响垃圾收集性能
    - 在默认情况下,当CPU数量小于8个,ParallelGCThreads的值等于CPU数量。
    - 当CPU数量大于8个,ParallelGCThreads的值等于
      3+[5+ CPU Count]/8]。

- -XX:MaxGCPauseMillis设置垃圾收集器最大停顿时间(即STW的时间)。单位是毫秒
  - 为了尽可能地把停顿时间控制在 MaxGCPauseMillis以内,收集器在工作时会调整Java堆大小或者其他一些参数
  - 对于用户来讲,停顿时间越短体验越好。但是在服务器端,我们注重高并发,整体的吞吐量。所以服务器端适合Parallel,进行控制。
  - 该参数使用需谨慎
- -xx: GCTimeRatio垃圾收集时间占总时间的比例(=1/(N+1))。
  用于衡量春吐量的大小。
  - 取值范围(0,100)。默认值99,也就是垃圾回收时间不超过1%。
  - 与前一个-xx: MaxGCPauseMillis参数有一定矛盾性。暂停时间越长, Radio参数就容易超过设定的比例

- -XX:+UseAdaptiveSizePolicy设置Parallel Scavenge收集器
  具有自适应调节策略
  - 在这种模式下,年轻代的大小、Eden和 Survivor的比例、晋升老年代的对象年龄等参数会被自动调整,以达到在堆大小、吞吐量和停顿时间之间的平衡点。
  - 在手动调优比较困难的场合,可以直接使用这种自适应的方式,仅指定虚拟机的最大堆、目标的吞吐量( GCTimeRatlo)和停顿时间( MaxGCPauseMillis),让虚拟机自己完成调优工作。

##### 6.CMS回收器:低延迟

- 在JDK1.5时期, Hotspot推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器:CMS( Concurrent-Mark-Sweep)收集器,这款收集器是 Hotspot虚拟机中第一款真正意义上的**并发收集器**,它第一次实现了让垃圾收集线程与用户线程同时工作
- CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短(低延迟)就越适合与用户交互的程序,良好的响应速度能提升用户体验
- **目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上,这类应用尤其重视服务的响应速度,希望系统停顿时间最短**,以给用户带来较好的体验CMS收集器就非常符合这类应用的需求。
- CMS的垃圾收集算法釆用标记-清除算法,并且也会〃Stop-The-world

- 不幸的是,CMS作为老年代的收集器,却无法与JDK1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作,所以在JDK1.5中使用CMS来收集老年代的时候,新生代只能选择 ParNew或者 Serial收集器中的一个。
- 在G1出现之前,CMS使用还是非常广泛的。一直到今天,仍然有很多系统使用 CMS GC。

![image-20220217122124797](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220217122124797.png)

###### CMS的工作原理

CMS整个过程比之前的收集器要复杂,整个过程分为4个主要阶段,即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段

- 初始标记( Initial-Mark)阶段:在这个阶段中,程序中所有的工作线程都将会因为stop-the-world”机制而出现短暂的暂停,这个阶段的主要任务仅仅只是标记出**GC Roots能直接关联到的对象**。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小,所以这里的速度非常快。
- 并发标记( Concurrent-Mark)阶段:从 GC Roots的直接关联对象开始遍历整个对象图的过程,这个过程耗时较长但是不需要停顿用户线程,可以与垃圾收集线程一起并发运行。
- 重新标记( Remark)阶段:由于在并发标记阶段中,程序的工作线程会和垃圾收集线程同时运行或者交叉运行,因此为了**修正并发标记期间,因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录**,这个阶段的停顿时间通常会比初始标记阶段稍长一些,但也远比并发标记阶段的时间短
- 并发清除( Concurrent- Sweep)阶段:此阶段**清理删除掉标记阶段判断的已经死亡的对象,释放内存空间**。由于不需要移动存活对象,所以这个阶段也是可以与用户线程同时并发的

尽管CMS收集器采用的是并发回收(非独占式),但是在其初始化标记和再次标记这两个阶段中仍然需要执行“stop-the-world”机制暂停程序中的工作线程,不过暂停时间并不会太长,因此可以说明目前所有的垃圾收集器都做不到完全不需要“stop-theworld”,只是尽可能地缩短暂停时间。

**由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作,所以整体的回收是低停顿的**。

另外,由于在垃圾收集阶段用户线程没有中断,所以在CMS回收过程中,还应该确保应用程序用户线程有足够的内存可用。因此,CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集,而是当**堆内存使用率达到某一阈值时,便开始进行回收**,以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要,就会出现一次“Concurrent Mode Failure”失败,这时虚拟机将启动后备预案:临时启用 Serial old收集器来重新进行老年代的垃圾收集,这样停顿时间就很长了。

CMS收集器的垃圾收集算法采用的是标记清除算法,这意味着每次执行完内存回收后,由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块,不可避免地将会产生一些内存碎片。那么CMS在为新对象分配内存空间时,将无法使用指针碰撞( Bump the Pointer)技术,而只能够选择空闲列表( Free list)执行内存分配

###### CMS的优点

- 并发收集
- 低延迟

###### CMS的弊端:

1. 会产生内存碎片,导致并发清除后,用户线程可用的空间不足。在无法分配大对象的情况下,不得不提前触发Full GC
2. CMS收集器对CPU资源非常敏感。在并发阶段,它虽然不会导致用户停顿,但是会因为占用了一部分线程而导致应用程序变慢,总吞吐量会降低。
3. CMS收集器无法处理浮动垃圾。可能出现“ Concurrent Mode Failure"失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的,那么在**并发标记阶段如果产生新的垃圾对象,CMS将无法对这些垃圾对象进行标记,最终会导致这些新产生的垃圾对象没有被及时回收**,从而只能在下一次执行GC时释放这些之前未被回收的内存空间。

###### CMS收集器可以设置的参数

- -XX:+UseConcMarkSweepGC手动指定使用CMS收集器执行内存回收任务开启该参数后会自动将-XX:+UseParNewGC打开。即: ParNew( Young区用)+CMs(Old区用)+ SerialOld的组合。
- ![image-20220217123744339](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220217123744339.png)
- =XX: CMSInitiatingOccupanyFraction设置堆内存使用率的阈值,一旦达到该阈值,便开始进行回收。
  - JDK5及以前版本的默认值为68,即当老年代的空间使用率达到68%时,会执行一次CMS回收。JDK6及以上版本默认值为92%
  - 如果内存增长缓慢,则可以设置一个稍大的值,大的阈值可以有效降低CMS的触发频率,减少老年代回收的次数可以较为明显地改善应用程序性能。反之,如果应用程序内存使用率増长很快,则应该降低这个阈值,以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低Full GC的执行次数。

- -XX:+ UseCMSCompactAtFullCollection用于指定在执行完Full
   GC后对内存空间进行压缩整理,以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行,所带来的问题就是停顿时间变得更长了
- -XX: CMSFullGCsBeforeCompaction设置在执行多少次FullGC后对内存空间进行压缩整理
- -XX:ParallelCMSThreads设置CMS的线程数量
  - CMs默认启动的线程数是(ParallelGCThreads+3)/4,
    ParallelGCThreads是年轻代并行收集器的线程数。当CPU资源比较紧张时,受到CMS收集器线程的影响,应用程序的性能在垃圾回收阶段可能会非常糟糕

###### 小结:

Hotspot有这么多的垃圾回收器,那么如果有人问, Serial GC、
Parallel GC、 Concurrent Mark Sweep GC这三个GC有什么不同呢?
请记住以下口令:

- 如果你想要最小化地使用内存和并行开销,请选 Serial GC
- 如果你想要最大化应用程序的吞吐量,请选Parallel GC
- 如果你想要最小化GC的中断或停顿时间,请选 CMS GC。

##### 7.G1回收器:区域化分代式

既然我们已经有了前面几个强大的GC,为什么还要发布 Garbage First(G1)GC?

- 原因就在于应用程序所应对的**业务越来越庞大、复杂,用户**越来越多,没有GC就不能保证应用程序正常进行,而经常造成STW的GC又跟不上实际的需求,所以才会不断地尝试对GC进行优化。G1( Garbage- First)垃圾回收器是在Java7 update 4之后引入的一个新的垃圾回收器,是当今收集器技术发展的最前沿成果之一
- 与此同时,为了适应现在**不断扩大的内存和不断增加的处理器数量**,进一步降低暂停时间( pause time),同时兼顾良好的吞吐量。
- 官方给G1设定的目标是在**延迟可控的情况下获得尽可能高的吞吐量**,所以才担当起“全功能收集器”的重任与期望

为什么名字叫做 Garbage First(G1)呢?

- 因为G1是一个并行回收器,它把堆内存分割为很多不相关的区域( Region)(物理上不连续的)。使用不同的 Region来表示Eden、幸存者0区,幸存者1区,老年代等
- G1GC有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个 Region里面的垃圾堆积的价值大小(回收所获得的空间大小以及回收所需时间的经验值),在后台维护一个优先列表,每次
- 根据允许的收集时间,优先回收价值最大的 Region由于这种方式的侧重点在于回收垃圾最大量的区间( Region),所以我们给G1一个名字:垃圾优先( Garbage First)。

G1( Garbage-irst)是一款面向服务端应用的垃圾收集器,主要针对**配**
**备多核CPU及大容量内有的机器**,以极高概率满足GC停顿时间的同时,还兼具高吞吐量的性能特征

在JDK1.7版本正式启用,移除了 Experimental的标识,是**JDK9以后的默认垃圾回收器**,取代了CMS回收器以及Parallel+Parallel Old组合
被 oracle官方称为“全功能的垃圾收集器”。

与此同时,CMS已经在JDK9中被标记为废弃( deprecated)。在jdk8中
还不是默认的垃圾回收器,需要使用-XX:+UseG1GC来启用。

###### G1回收器的特点(优势)

与其他GC收集器相比,G1使用了全新的分区算法,其特点如下所示:

- 并行与并发
  - 并行性:G1在回收期间,可以有多个GC线程同时工作,有效利用多核计算能力。此时用户线程STW
  - 并发性:G1拥有与应用程序交替执行的能力,部分工作可以和应用程序同时执行,因此,一般来说,不会在整个回收阶段发生完全阻塞应用程序的情况
- 分代收集
  - 从分代上看,G1依然属于**分代型垃圾回收器**,它会区分年轻代和老年代,年轻代依然有Eden区和 Survivor区。但从堆的结构上看,它不要求整个Eden区、年轻代或者老年代都是连续的,也不再坚持固定大小和固定数量。
  - 将堆空间分为若干个区域( Region),这些区域中包含了逻辑上的年轻代和老年代。
  - 和之前的各类回收器不同,它同时兼顾年轻代和老年代。对比其他回收器,或者工作在年轻代,或者工作在老年代;

- 空间整合
  - CMS:“标记-淸除”算法、内存碎片、若干次GC后进行一次碎片整理
  - G1将内存划分为一个个的 region。内存的回收是以 regIon作为基本单位的。**Region之间是复制算法**,**但整体上实际可看作是标记-压缩(Mark- Compact)算法**,两种算法都可以避免内存碎片。这种特性有利于程序长时间运行,分配
    大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候,G1的优势更加明显。

- 可预测的停顿时间模型(即:软实时 soft real-time)
  这是G1相对于CMS的另一大优势,G1除了追求低停顿外,还能建立可预测的停顿时间模型,能让使用者明确指定在一个长度为M毫秒的时间片段内,消耗在垃圾收集上的时间不得超过N毫秒。
  - 由于分区的原因,G1可以只选取部分区域进行内存回收,这样缩小了回收的范围,因此对于全局停顿情况的发生也能得到较好的控制
  - G1跟踪各个 Region里面的垃圾堆积的价值大小(回收所获得的空间大小以及回收所需时间的经验值),在后台维护一个优先列表,每次根据允许的收集时间,优先回收价值最大的 Region。保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。
  - 相比于CMSGC,G1未必能做到CMS在最好情况下的延时停顿,但是最差情况要好很多。

###### G1回收器的缺点

- 相较于CMS,G1还不具备全方位、压倒性优势。比如在用户程序运行过程中G1无论是为了垃圾收集产生的内存占用( Footprint)还是程序运行时的额外执行负载(overload)都要比CMS要高。
- 从经验上来说,在小内存应用上CMS的表现大概率会优于G1,而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间

###### G1回收器的参数设置

- -XX:+UseG1GC手动指定使用G1收集器执行内存回收任务。
- -XX:G1HeapRegionSize设置每个 Region的大小。值是2的幂,范围是IMB到32MB之间,目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。
- -XX:MaxGcPauseMillis设置期望达到的最大GC停顿时间指标(JVM会尽力实现,但不保证达到)。默认值是200ms
- -XX:ParallelGCThread设置STW工作线程数的值。最多设置为8
- -XX: ConcGCThreads设置并发标记的线程数。将n设置为并行垃圾回收线程数(ParallelGCThreads)的1/4左右。
- -XX: InitiatingHeapOccupancyPercent设置触发并发GC周期的Java堆占用率阈值。超过此值,就触发GC。默认值是45%。

###### G1回收器的常见操作步骤

G1的设计原则就是简化υWM性能调优,开发人员只需要简单的三步即可完成调优:

- 第一步:开启G1垃圾收集器
- 第二步:设置堆的最大内存
- 第三步:设置最大的停顿时间
  G1中提供了三种垃圾回收模式: Young GC、 Mixed GC和Full GC,在不同的条件下被触发

###### G1回收器的适用场景

- 面向服务端应用,针对具有大内存、多处理器的机器。(在普通大小的堆里表现并不惊喜)
- 最主要的应用是需要低GC延迟,并具有大堆的应用程序提供解决方案;
- 如:在堆大小约6GB或更大时,可预测的暂停时间可以低于8.5秒;(G1通过每次只清理一部分而不是全部的 Region的增量式清理来保证每次GC停顿时间不会过长)。
- 用来替换掉JDK1.5中的CMS收集器在下面的情况时,使用G1可能比CMS好
  1. 超过50%的]ava堆被活动数据占用;
  2. 对象分配频率或年代提升频率变化很大
  3. GC停顿时间过长(长于8.5至1秒)。
- Hotspot垃圾收集器里,除了G1以外,其他的垃圾收集器使用内置的JVM线程执行GC的多线程操作,而G1GC可以采用应用线程承担后台运行的GC工作,即当J的GC线程处理速度慢时,系统会调用应用程序线程帮助加速垃圾回收过程

###### 分区 Region:化整为零

使用G1收集器时,它将整个Java堆划分成约2048个大小相同的独立 Region块,每个 Region块大小根据堆空间的实际大小而定,整体被控制在1MB到32MB之间,且为2的N次幂,1MB,2MB,4MB,8MB,16MB,32MB。可以通过-XX:G1HeapRegionsize设定。所有的 Region大小相同,且在JVM生命周期内不会被改变。

虽然还保留有新生代和老年代的概念,但新生代和老年代不再是物理隔离的了,它们都是一部分 Region(不需要连续)的集合。通过 Region的动态分配方式实现逻辑上的连续。

![image-20220217131225569](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220217131225569.png)

- 一个 region有可能属于Eden, Survivor或者Old/ Tenured内存区域。但是一个 region只可能属于一个角色。图中的E表示该 region属于Eden内存区域,s表示属于 Survivor内存区域,o表示属于old内存区域。图中空白的表示未使用的内存空间。

- G1垃圾收集器还增加了一种新的内存区域,叫做 Humongous内存区域,如图中的H块。主要用于存储大对象,如果超过1.5个 region,就放到H

- 设置H的原因:
  对于堆中的大对象,默认直接会被分配到老年代,但是如果它是一个短期存在的大对象就会对垃圾收集器造成负面影响。为了解决这个问题,G1划分了一个 Humongous区,它用来专门存放大对象。如果一个H区装不下一个大对象,那么G1会寻找连续的H区来
  存储。为了能找到连续的H区,有时候不得不启动FullGC。G1的大多数行为都把H区作为老年代的一部分来看待。

###### G1回收器垃圾回收过程

G1GC的垃圾回收过程主要包括如下三个环节

- 年轻代GC( Young gC)
- 老年代并发标记过程( Concurrent Marking)
- 混合回收( Mixed GC)
- (如果需要,单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制,即强力回收)

![image-20220217131724923](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220217131724923.png)

顺时针, young gc-> young gc+ concurrent mark-> Mixed gc顺序
进行垃圾回收。

应用程序分配内存,当年轻代的Eden区用尽时开始年轻代回收过程;G1的年轻代收集阶段是一个并行的独占式收集器。在年轻代回收期,G1GC暂停所有应用程序线程,启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到 Survivor区间或者老年区间,也有
可能是两个区间都会涉及。

当堆内存使用达到一定值(默认45%)时,开始老年代并发标记过程。

标记完成马上开始混合回收过程。对于一个混合回收期,G1GC从老年区间移动存活对象到空闲区间,这些空闲区间也就成为了老年代的一部分。和年轻代不同,老年代的G1回收器和其他GC不同,G1的老年代回收器不需要整个老年代被回收,一次只需要扫描/回收小部分老年代的 Region就可以了。同时,这个老年代 Region是和年轻代一起被回收的。

举个例子:一个Web服务器,Java进程最大堆内存为4G,每分钟响应1500个请求,每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收,每31个小时整个堆的使用率会达到45%,会开始老年代并发标记过程,标记完成后开始四到五次的混合回收。

G1回收垃圾回收过程: Remembered set

- 一个对象被不同区域引用的问题
- 一个 Region不可能是孤立的,一个 Region中的对象可能被其他任意 Region中对象引用,判断对象存活时,是否需要扫描整个Java堆才能保证准确?
- 在其他的分代收集器,也存在这样的问题(而G1更突出)
- 回收新生代也不得不同时扫描老年代?
- 这样的话会降低 Minor GC的效率;
- 解决方法:
  - 无论G1还是其他分代收集器,JVM都是使用 Remembered set来避免全局扫描:
  - 每个 Region都有一个对应的 Remembered set;
  - 每次 Reference类型数据写操作时,都会产生一个 Write barrier暂时中断操作;
  - 然后检查将要写入的引用指向的对象是否和该 Reference类型数据在不同的 Region(其他收集器:检査老年代对象是否引用了新生代对象);
  - 如果不同,通过 CardTable把相关引用信息记录到引用指向对象的所在 Region对应的Remembered set中;当进行垃圾收集时,在GC根节点的枚举范围加入 Remembered set;就可以保证不进行全局扫描,也不会有遗漏。

![image-20220217132500645](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220217132500645.png)

G1回收过程一:年轻代GC
JVM启动时,G1先准备好Eden区,程序在运行过程中不断创建对象到Eden区,当Eden空间耗尽时,G1会启动一次年轻代垃圾回收过程。

年轻代垃圾回收只会回收Eden区和 Survivor区

YGC时,首先G1停止应用程序的执行(Stop-The- World),G1创建回收
集(collection set),回收集是指需要被回收的内存分段的集合,年轻代回收过程的回收集包含年轻代Eden区和 Survivor区所有的内存分段。

然后开始如下回收过程:
第一阶段,扫描根。
根是指 static变量指向的对象,正在执行的方法调用链条上的局部变量等。根引用连同Rset记录的外部引用作为扫描存活对象的入口。
第二阶段,更新Rset。
处理 dirty card queue(见备注)中的card,更新Rset。此阶段完成后,Rset可以准确的反映老年代对所在的内存分段中对象的引用。
第三阶段,处理RSet。
识别被老年代对象指向的Eden中的对象,这些被指向的Eden中的对象被认为是存活的对象。
第四阶段,复制对象
此阶段,对象树被遍历,Eden区内存段中存活的对象会被复制到 Survivor区中空的内存分段Survivor区内存段中存活的对象如果年龄未达阈值,年龄会加1,达到阀值会被会被复制到old区中空的内存分段。如果 Survivor空间不够,Eden空间的部分数据会直接晋升到老年代空间
第五阶段,处理引用。
处理Soft,Weak, Phantom,Final, JNI Weak等引用。最终Eden空间的数据为空,GC停止工作,而目标内存中的对象都是连续存储的,没有碎片,所以复制过程可以达到内存整理的效果,减少碎片。

G1回收过程二:并发标记过程

1. 初始标记阶段:标记从根节点直接可达的对象。这个阶段是STW的,并且会触发一次年轻代GC。
2. 根区域扫描( Root Region Scanning):G1GC扫描 Survivor区直接可达的老年代区域对象,并标记被引用的对象。这一过程必须在 young GC之前完成。
3. 并发标记( Concurrent Marking):在整个堆中进行并发标记(和应用程序并发执行),此过程可能被younεGC中断。在并发标记阶段,若发现区域对象中的所有对象都是垃圾,那这个区域会被立即回收。同时,并发标记过程中,会计算每个区域的对象活性(区域中
   存活对象的比例)。
4. 再次标记( Remark):由于应用程序持续进行,需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的初始快照算法: snapshot-at-the- beginning(SATB)。
5. 独占清理( cleanup,STW):计算各个区域的存活对象和GC回收比例,并进行排序,识别可以混合回收的区域。为下阶段做铺垫。是STW的。这个阶段并不会实际上去做垃圾的收集
6. 并发清理阶段:识别并清理完全空闲的区域。

G1回收过程三:混合回收
当越来越多的对象晋升到老年代old region时,为了避免堆内存被耗尽,虚拟机会触发一个混合的垃圾收集器即 Mixed GC,该算法并不是一个old GC,除了回收整个 Young Region,还会回收一部分的old region。这里需要注意:是一部分老年代,而不是全部老年代。可以选择哪些old Region进行收集,从而可以对垃圾回收的耗时时间进行控制。也要注意的是 Mixed GC并不是Full GC。



![image-20220217133719387](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220217133719387.png)

- 并发标记结束以后,老年代中百分百为垃圾的内存分段被回收了,部分为垃圾的内存分段被计算了出来。默认情况下,这些老年代的内存分段会分8次(可以通过-XX:G1MixedGCCountTarget设置)被回收。
- 混合回收的回收集(Collection Set)包括八分之一的老年代内存分段,Eden区内存分段, Survivor区内存分段。混合回收的算法和年轻代回收的算法完全一样,只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。
- 由于老年代中的内存分段默认分8次回收,G1会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的,越会被先回收。并且有一个阈值会决定内存分段是否被回收,-XX:G1MixedGCLiveThresholdPercent,默认为65%,意思是垃圾占内存分段比例要达到65%才会被回收。如果垃圾占比太低,意味着存活的对象占比高,在复制的时候会花费更多的时间。
- 混合回收并不一定要进行8次。有一个阈值-XX:G1HeapWastePercent,默认值为10%,意思是允许整个堆内存中有10%的空间被浪费,意味着如果发现可以回收的垃圾占堆内存的比例低于10%,则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少

G1回收可选的过程四:FuGC
G1的初衷就是要避免Full GC的出现。但是如果上述方式不能正常工作,G1会停止应用程序的执行(Stop-The- World),使用单线程的内存回收算法进行垃圾回收,性能会非常差,应用程序停顿时间会很长

要避免 Full GC的发生,一旦发生需要进行调整。什么时候会发生Full GC呢?比如堆内存太小,当G1在复制存活对象的时候没有空的内存分段可用则会回退到full GC,这种情况可以通过增大内存解决。导致

G1FullGC的原因可能有两个:

1. Evacuation的时候没有足够的to- space来存放晋升的对象
2. 并发处理过程完成之前空间耗尽

##### 8.垃圾回收器总结

![image-20220217134556067](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220217134556067.png)

怎么选择垃圾回收器?
Java垃圾收集器的配置对于JVM优化来说是一个很重要的选择,选择合适的垃圾收集器可以让J的性能有一个很大的提升
怎么选择垃圾收集器?

1. 优先调整堆的大小让JⅥM自适应完成
2. 如果内存小于100M,使用串行收集器
3. 如果是单核、单机程序,并且没有停顿时间的要求,串行收集器
4. 如果是多CPU、需要高吞吐量、允许停顿时间超过1秒,选择并行或者JVM自己选择
5. 如果是多CPU、追求低停顿时间,需快速响应(比如延迟不能超过1秒,如互联网应用),使用并发收集器
6. 官方推荐G1,性能高。现在互联网的项目,基本都是使用G1

##### 9.GC日志分析

通过阅读GC日志,我们可以了解]ava虚拟机内存分配与回收策略。
内存分配与垃圾回收的参数列表
-XX: +PrintGC 输出GC日志。类似:- verbose:gc
-XX:+PrintGCDetails 输出GC的详细日志
-XX:+PrintGCTimeStamps 输出GC的时间戳(以基准时间的形式)
-XX:+PrintGCDateStamps输出GC的时间戳(以日期的形式,如2013-05-04T21:53:59.234+0800)
-XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息
-XLoggc:../logs/gc.log 日志文件的输出路径

![image-20220217140824674](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220217140824674.png)

![image-20220217141003831](C:\Users\YQ\AppData\Roaming\Typora\typora-user-images\image-20220217141003831.png)

```
#对象分配内存失败，Young区发生GC，从15M-->2M，总17M，堆从15M-->4M，总58M，GC时间0.0074512s，Young区减少13M，堆只减少了11M，所以有2M对象到了Old区<br>
2019-07-15T10:38:52.441+0800: 0.654: [GC (Allocation Failure) [PSYoungGen: 15360K->2544K(17920K)] 15360K->4022K(58880K), 0.0074512 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] 
```

